<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Zcash Supply & Issuance</title>
<style>
  :root{
    --bg:#0f172a; --fg:#e2e8f0; --muted:#94a3b8; --panel:#0b1224;
    --supplyObs:#f59e0b; --issObs:#22d3ee;
    --supplyExp:rgba(245,158,11,0.55); --issExp:rgba(34,211,238,0.55);
    --annualObs:#4ade80; --annualExp:rgba(74,222,128,0.55);
    --eventObs:rgba(96,165,250,0.45); --eventHalv:rgba(239,68,68,0.35);
    --written:rgba(167,139,250,0.65);
    --zip234Supply: #38bdf8;   /* sky-400 */
    --zip234Iss: #7dd3fc;      /* sky-300 */
    --zip234Ann: #38bdf8;
    --zip234Act: rgba(56,189,248,0.50);
    --handleBg: rgba(56,189,248,0.92);
    --handleBorder: #fff;
    --burnHandleBg:rgba(248,113,113,0.88);--burnHandleBorder:rgba(248,113,113,0.5);
    --burnEvent:rgba(255,80,80,0.70);
    --controlsBg:rgba(2,6,23,0.25); --controlsBorder:rgba(148,163,184,0.15);
    --btnBg:rgba(2,6,23,0.25); --btnBorder:rgba(148,163,184,0.22);
    --btnHover:rgba(148,163,184,0.4);
    --tooltipBg:rgba(15,23,42,0.98); --tooltipBorder:rgba(148,163,184,0.25);
    --gridLine:rgba(148,163,184,0.08); --capLine:rgba(245,158,11,0.20);
    --frameBorder:rgba(148,163,184,0.10);
    --toggleActiveBg:rgba(148,163,184,0.08); --toggleHoverBg:rgba(148,163,184,0.12);
  }
  [data-theme="light"]{
    --bg:#f8fafc; --fg:#1e293b; --muted:#64748b; --panel:#ffffff;
    --supplyObs:#d97706; --issObs:#0891b2;
    --supplyExp:rgba(217,119,6,0.55); --issExp:rgba(8,145,178,0.55);
    --annualObs:#16a34a; --annualExp:rgba(22,163,74,0.55);
    --eventObs:rgba(59,130,246,0.35); --eventHalv:rgba(220,38,38,0.30);
    --written:rgba(124,58,237,0.55);
    --zip234Supply: #0284c7;   /* sky-600 */
    --zip234Iss: #0369a1;      /* sky-700 */
    --zip234Ann: #0284c7;
    --zip234Act: rgba(2,132,199,0.40);
    --handleBg: rgba(2,132,199,0.92);
    --handleBorder: #1e293b;
    --burnHandleBg:rgba(220,38,38,0.88);--burnHandleBorder:rgba(220,38,38,0.5);
    --burnEvent:rgba(220,38,38,0.60);
    --controlsBg:rgba(241,245,249,0.85); --controlsBorder:rgba(148,163,184,0.25);
    --btnBg:rgba(255,255,255,0.8); --btnBorder:rgba(148,163,184,0.35);
    --btnHover:rgba(148,163,184,0.55);
    --tooltipBg:rgba(255,255,255,0.98); --tooltipBorder:rgba(148,163,184,0.35);
    --gridLine:rgba(148,163,184,0.12); --capLine:rgba(217,119,6,0.25);
    --frameBorder:rgba(148,163,184,0.18);
    --toggleActiveBg:rgba(148,163,184,0.12); --toggleHoverBg:rgba(148,163,184,0.18);
  }
  *{margin:0;padding:0;box-sizing:border-box}
  body{background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,sans-serif;
    display:flex;flex-direction:column;align-items:center;padding:22px;gap:10px}
  h1{font-size:1.35rem;color:var(--supplyObs);margin-bottom:2px}
  .sub{font-size:.82rem;color:var(--muted);text-align:center;max-width:760px;line-height:1.45}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center;justify-content:center;
    background:var(--controlsBg);border:1px solid var(--controlsBorder);border-radius:10px;padding:10px 18px}
  .controls button{font:600 .78rem/1 system-ui;color:var(--fg);background:var(--btnBg);
    border:1px solid var(--btnBorder);border-radius:6px;padding:7px 14px;cursor:pointer;transition:background .12s}
  .controls button:hover{background:var(--btnHover)}
  .chart-wrap{position:relative;display:inline-block}
  canvas{border-radius:8px;background:var(--panel);display:block}
  .legend{display:flex;flex-wrap:wrap;gap:10px 20px;font-size:.78rem;align-items:center;justify-content:center;color:var(--muted)}
  .legend span{display:flex;align-items:center;gap:5px}
  .sw{width:10px;height:10px;border-radius:50%;display:inline-block;flex-shrink:0}
  .dash{width:18px;height:0;border-top:2px dashed var(--muted);display:inline-block}
  .ltoggle{cursor:pointer;user-select:none;padding:4px 10px;border-radius:999px;
    border:1.5px solid transparent;transition:opacity .15s,border-color .15s,background .15s}
  .ltoggle.active{border-color:var(--btnBorder);background:var(--toggleActiveBg);opacity:1}
  .ltoggle:not(.active){opacity:.38}
  .ltoggle:not(.active) .sw{background:var(--muted)!important}
  .ltoggle:hover{opacity:.85;background:var(--toggleHoverBg)}
  /* Draggable activation handle â€” ABOVE the chart with gap */
  #actHandle{position:absolute;display:none;z-index:20;cursor:ew-resize;
    transform:translateX(-50%);pointer-events:auto;top:-8px}

  #actHandle .act-pill{
    background:var(--handleBg);color:#fff;font:600 .68rem/1 system-ui;
    padding:5px 8px;border-radius:6px;border:1.5px solid var(--handleBorder);
    white-space:nowrap;display:flex;flex-direction:column;align-items:center;gap:4px;
    box-shadow:0 2px 8px rgba(0,0,0,.3);user-select:none;opacity:0.9;
    transition:opacity 0.15s,filter 0.15s}
  #actHandle .act-content{display:flex;align-items:stretch;gap:8px;width:100%}
  #actHandle .act-left{display:flex;flex-direction:column;align-items:center;
    justify-content:center;gap:3px}
  #actHandle .act-pill .act-label { opacity: 0.85; font-size: .66rem; }
  #actHandle .act-collapse-icon {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: rgba(255,255,255,0.15);
    color: rgba(255,255,255,0.8);
    font: 600 11px/18px system-ui;
    text-align: center;
    cursor: pointer;
    transition: background 0.12s;
  }
  #actHandle .act-collapse-icon:hover {
    background: rgba(255,255,255,0.3);
  }
  #actHandle .act-right {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 3px;
  }
  #actHandle .act-pill input{width:80px;padding:2px 4px;border-radius:3px;border:1px solid rgba(255,255,255,.3);
    background:rgba(0,0,0,.25);color:#fff;font:600 .66rem/1 system-ui;text-align:center}
  #actHandle .act-pill input.act-date{width:88px}

  #actHandle .act-stem{width:2px;background:var(--handleBg);margin:0 auto}

  #burnHandle{position:absolute;display:none;z-index:19;cursor:ew-resize;
      transform:translateX(-50%);pointer-events:auto;top:-8px}
  #burnHandle .burn-nub{display:none;width:24px;height:16px;border-radius:8px;
      background:var(--burnHandleBg);color:#fff;font:600 11px/16px system-ui;text-align:center;
      border:1.5px solid var(--burnHandleBorder);cursor:ew-resize;box-shadow:0 2px 8px rgba(0,0,0,.3)}
  #burnHandle.collapsed .burn-nub{display:block}
  #burnHandle.collapsed .burn-pill{display:none}
  #burnHandle .burn-pill{
    background:var(--burnHandleBg);color:#fff;font:600 .68rem/1 system-ui;
    padding:5px 8px;border-radius:6px;border:1.5px solid var(--burnHandleBorder);
    white-space:nowrap;display:flex;flex-direction:column;align-items:center;gap:4px;
    box-shadow:0 2px 8px rgba(0,0,0,.3);user-select:none;opacity:0.9;
    transition:opacity 0.15s,filter 0.15s}
  #burnHandle .burn-content{display:flex;align-items:stretch;gap:8px;width:100%}
  #burnHandle .burn-left{display:flex;flex-direction:column;align-items:center;
    justify-content:center;gap:3px}
  #burnHandle .burn-pill .burn-label{opacity:0.85;font-size:.66rem}
  #burnHandle .burn-collapse-icon{width:18px;height:18px;border-radius:50%;
      background:rgba(255,255,255,0.15);color:rgba(255,255,255,0.8);
      font:600 11px/18px system-ui;text-align:center;cursor:pointer;transition:background 0.12s}
  #burnHandle .burn-collapse-icon:hover{background:rgba(255,255,255,0.3)}
  #burnHandle .burn-right{display:flex;flex-direction:column;align-items:flex-end;gap:3px}
  #burnHandle .burn-pill input{width:80px;padding:2px 4px;border-radius:3px;
      border:1px solid rgba(255,255,255,.3);background:rgba(0,0,0,.25);color:#fff;
      font:600 .66rem/1 system-ui;text-align:center}
  #burnHandle .burn-pill input.burn-date{width:88px}
  #burnHandle .burn-amt-row{display:flex;align-items:center;gap:3px}
  #burnHandle .burn-pill .burn-unit{opacity:0.7;font-size:.62rem}
  #burnHandle .burn-stem{width:2px;background:var(--burnEvent);margin:0 auto}
#burnHandle .burn-mode-row{display:flex;align-items:center;gap:4px;margin-top:3px}
#burnHandle .burn-mode-group{display:inline-flex;border:1px solid rgba(255,255,255,.25);border-radius:4px;overflow:hidden}
#burnHandle .burn-mode-btn{padding:1px 6px;font:600 .58rem/1.2 system-ui;border:none;
  border-right:1px solid rgba(255,255,255,.2);background:transparent;color:rgba(255,255,255,.55);
  cursor:pointer;transition:all 0.12s}
#burnHandle .burn-mode-btn:last-child{border-right:none}
#burnHandle .burn-mode-btn.active{background:rgba(255,255,255,.2);color:#fff}
#burnHandle .burn-mode-btn:hover{background:rgba(255,255,255,.12)}

#burnHandle .burn-info-icon{position:relative;cursor:help;font-size:.6rem;opacity:0.65;user-select:none}
#burnHandle .burn-info-tip{display:none;position:absolute;bottom:100%;left:50%;transform:translateX(-50%);
  width:210px;padding:6px 8px;border-radius:6px;font:normal .62rem/1.4 system-ui;
  background:var(--tooltipBg);color:var(--fg);border:1px solid var(--tooltipBorder);
  box-shadow:0 4px 12px rgba(0,0,0,.3);white-space:normal;text-align:left;z-index:100;margin-bottom:6px}
#burnHandle .burn-info-icon:hover .burn-info-tip{display:block}

  #actHandle .act-nub {
    display: none;
    width: 44px;
    height: 16px;
    border-radius: 8px;
    background: var(--handleBg);
    border: 1.5px solid var(--handleBorder);
    cursor: ew-resize;
    margin: 0 auto;
    box-shadow: 0 1px 4px rgba(0,0,0,.3);
    color: #fff;
    font: 600 11px/16px system-ui;
    text-align: center;
    letter-spacing: 2px;
    user-select: none;
    opacity: 0.85;
    transition: opacity 0.15s;
  }
  #actHandle .act-pill:hover {
    opacity: 1;
    filter: brightness(1.15);
  }
  #actHandle .act-nub:hover {
    opacity: 1;
  }
  #actHandle.collapsed .act-nub { display: block; }
  #actHandle.collapsed .act-pill { display: none; }
  [data-theme="light"] #actHandle .act-pill input{background:rgba(255,255,255,.5);color:#1e293b;border-color:rgba(0,0,0,.2)}
  /* Written tooltip */
  #writtenTip{position:fixed;display:none;z-index:15;pointer-events:none;
    background:var(--tooltipBg);color:var(--fg);border:1px solid var(--tooltipBorder);
    border-radius:6px;padding:8px 12px;font-size:.72rem;line-height:1.4;
    backdrop-filter:blur(6px);-webkit-backdrop-filter:blur(6px);white-space:nowrap;
    transform:translateX(-50%)}
  #tooltip{position:fixed;display:none;border-radius:8px;padding:10px 14px;font-size:.76rem;
    pointer-events:none;z-index:10;line-height:1.55;max-width:400px;
    background:var(--tooltipBg);color:var(--fg);border:1px solid var(--tooltipBorder);
    backdrop-filter:blur(6px);-webkit-backdrop-filter:blur(6px)}
  #tooltip .tt-muted{color:var(--muted)} #tooltip .tt-obs{color:#38bdf8;font-weight:600}
  #tooltip .tt-exp{color:var(--written);font-weight:600}
  @media(max-width:600px){body{padding:10px;gap:8px}h1{font-size:1.1rem}.sub{font-size:.72rem}
    .controls{padding:8px 10px;gap:6px}.controls button{padding:8px 10px;font-size:.72rem;min-height:36px}
    .legend{font-size:.7rem;gap:6px 12px}.ltoggle{padding:6px 12px;min-height:36px}}
.seg-label { color: var(--muted); font-size: 0.78rem; margin-right: 2px; }
.seg-group { display: inline-flex; border: 1px solid var(--controlsBorder); border-radius: 6px; overflow: hidden; }
.seg { padding: 3px 10px; font-size: 0.75rem; border: none; border-right: 1px solid var(--controlsBorder);
  background: transparent; color: var(--muted); cursor: pointer; transition: all 0.15s; }
.seg:last-child { border-right: none; }
.seg:hover { opacity: 0.85; }
.seg.active[data-mode="both"]    { background: var(--frameBorder); color: var(--fg); }
.seg.active[data-mode="default"] { background: rgba(245,158,11,0.25); color: var(--supplyObs); }
.seg.active[data-mode="zip234"]  { background: rgba(56,189,248,0.25); color: var(--zip234Supply); }
</style>
</head>
<body>
<h1>Zcash Supply &amp; Issuance</h1>
<p class="sub">
  Zcash consensus issuance logic with optional <b>ZIP 234</b> smooth-issuance overlay.<br>
  <b>Scroll</b> to pan, <b>Ctrl/âŒ˜+scroll</b> (or pinch) to zoom, <b>drag</b> to pan, <b>double-click</b> to reset.
</p>
<div class="chart-wrap" id="chartWrap">
  <canvas id="chart"></canvas>
  <div id="actHandle">
    <div class="act-nub">â‹¯</div>
    <div class="act-pill">
      <div class="act-content">
        <div class="act-left">
          <span class="act-label">ZIP 234 activation</span>
        </div>
        <div class="act-right">
          <input id="actBlockInput" type="text" value="3687123">
          <input id="actDateInput" type="text" class="act-date" value="">
        </div>
      </div>
      <span class="act-collapse-icon" title="Click to collapse">â–¾</span>
    </div>
    <div class="act-stem"></div>
  </div>
  <div id="burnHandle">
    <div class="burn-nub">â‹¯</div>
    <div class="burn-pill">
      <div class="burn-content">
        <div class="burn-left">
          <span class="burn-label">Burn</span>
          <div class="burn-amt-row"><input id="burnAmtInput" type="text" value="2000000"><span class="burn-unit">â“©</span></div>
        </div>
        <div class="burn-right">
          <input id="burnBlockInput" type="text" value="5000000">
          <input id="burnDateInput" type="text" class="burn-date" value="">
          <div class="burn-mode-row">
            <span class="burn-mode-group" id="burnModeGroup">
              <button class="burn-mode-btn active" data-burn-mode="once">Once</button>
              <button class="burn-mode-btn" data-burn-mode="perblock">/blk</button>
            </span>
            <span class="burn-info-icon" id="burnInfoIcon">â“˜
              <span class="burn-info-tip">
                <b>Once</b>: a single burn at this block.<br>
                <b>/blk</b>: this amount is burned every block from here on.
              </span>
            </span>
          </div>
        </div>
      </div>
      <span class="burn-collapse-icon" title="Click to collapse">â–¾</span>
    </div>
    <div class="burn-stem"></div>
  </div>
  <div id="writtenTip"></div>
</div>
<div class="legend" id="legend">
<span class="seg-label">Future:</span>
  <span class="seg-group" id="futureModeGroup">
    <button class="seg active" data-mode="both">Both</button>
    <button class="seg" data-mode="default">Default</button>
    <button class="seg" data-mode="zip234">ZIP 234</button>
  </span>
  <span>|</span>
  <span style="color:var(--muted)">â”‚</span>
  <span class="ltoggle active" data-series="supply"><span class="sw" style="background:var(--supplyObs)"></span>Supply</span>
  <span class="ltoggle active" data-series="issDay"><span class="sw" style="background:var(--issObs)"></span>Issuance / Day</span>
  <span class="ltoggle" data-series="annPct"><span class="sw" style="background:var(--annualObs)"></span>Annual %</span>
  <span><span class="dash"></span> Dashed = <b>Expected</b></span>
</div>
<div id="tooltip"></div>
<div class="controls">
  <button id="btnReset">Reset view</button>
  <button id="btnTheme">â˜€/ðŸŒ™</button>
</div>
<script>
/* ================================================================
   Toggle state
   ================================================================ */
const show = {supply:true, issDay:true, annPct:false};
let futureMode = 'both'; // 'default' | 'zip234' | 'both'
function showDefaultFuture() { return futureMode !== 'zip234'; }
function showZip234() { return futureMode !== 'default'; }

function zatToZec(zat) { return Number(zat) / 1e8; }
function annPctVal(p) { return p.annualPctX1M < 0n ? NaN : Number(p.annualPctX1M) / 1e6; }

function zatToZecString(zat) {
    if (zat < 0n) return "-" + zatToZecString(-zat);
    const w = zat / 100_000_000n, f = zat % 100_000_000n;
    const fs = String(f).padStart(8, '0').replace(/0+$/, '');
    let ws = String(w), out = '';
    for (let i = 0; i < ws.length; i++) {
        if (i > 0 && (ws.length - i) % 3 === 0) out += ',';
        out += ws[i];
    }
    return fs ? out + '.' + fs : out;
}

function parseZecToZat(str) {
    str = str.replace(/,/g, '').trim();
    if (!str) return null;
    const neg = str.startsWith('-');
    if (neg) str = str.substring(1);
    const dot = str.indexOf('.');
    let whole = dot >= 0 ? str.substring(0, dot) : str;
    let frac  = dot >= 0 ? str.substring(dot + 1) : '';
    whole = whole.replace(/[^0-9]/g, '') || '0';
    frac = (frac.replace(/[^0-9]/g, '') + '00000000').substring(0, 8);
    try { const v = BigInt(whole) * 100_000_000n + BigInt(frac); return neg ? -v : v; }
    catch(e) { return null; }
}

/* ================================================================
   Theme
   ================================================================ */
function getTheme(){return document.documentElement.getAttribute("data-theme")||"dark";}
function setTheme(t){if(t==="light")document.documentElement.setAttribute("data-theme","light");
  else document.documentElement.removeAttribute("data-theme");try{localStorage.setItem("zec-theme",t)}catch(e){}}
function toggleTheme(){setTheme(getTheme()==="dark"?"light":"dark");requestDraw();}
function initTheme(){try{const s=localStorage.getItem("zec-theme");if(s){setTheme(s);return;}}catch(e){}
  if(window.matchMedia&&window.matchMedia("(prefers-color-scheme:light)").matches)setTheme("light");}
function cv(name){return getComputedStyle(document.documentElement).getPropertyValue(name).trim();}

/* ================================================================
   Time anchors
   ================================================================ */
const TIME_ANCHORS=[
  {h:0n,time:Date.UTC(2016,9,28,7,56),label:"Genesis"},
  {h:653_600n,time:Date.UTC(2019,11,11,21,50),label:"Blossom"},
  {h:1_046_400n,time:Date.UTC(2020,10,18,12,34),label:"Halving 1"},
  {h:2_726_400n,time:Date.UTC(2024,10,23,1,51),label:"Halving 2"},
];

const BLOSSOM_ACTIVATION_HEIGHT=653_600n;
const WRITTEN_HEIGHT=3_234_946n;
const BURN_EVENTS = [{ h: 4_500_000n, zat: 2_000_000_000_000_00n, label: "Burn 2M â“©", mode: 'once'}];
BURN_EVENTS[0].label = formatBurnLabel(BURN_EVENTS[0].zat, BURN_EVENTS[0].mode);

function totalBurnedAtHeight(h){let total=0;for(const b of BURN_EVENTS)if(h>=b.h)total+=zatToZecString(b.zat);return total;}
const ONE_YEAR_MS=BigInt(365.25*86400*1000);

const SEGMENTS=[];
for(let i=0;i<TIME_ANCHORS.length-1;i++){
  const a=TIME_ANCHORS[i],b=TIME_ANCHORS[i+1];
  SEGMENTS.push({startH:a.h,endH:b.h,startTime:a.time,
    secPerBlock:BigInt(b.time-a.time)/1000n/(b.h-a.h)});
}

function segmentForHeight(h){for(let i=0;i<SEGMENTS.length;i++)if(h<=SEGMENTS[i].endH)return SEGMENTS[i];return SEGMENTS[SEGMENTS.length-1];}
function blockToTime(h){
    const s=segmentForHeight(h);return s.startTime+(h-s.startH)*s.secPerBlock*1000;
}
function secsPerBlock(h){return segmentForHeight(h).secPerBlock;}
function timeToHeight(t){
    for(let i=SEGMENTS.length-1;i>=0;i--){
        const s=SEGMENTS[i];
        if(t>=s.startTime)
            return BigInt(s.startH) + BigInt(t-s.startTime) / (BigInt(s.secPerBlock)*1000n);
    }
    const s=SEGMENTS[0];
    return BigInt(s.startH) + BigInt(t-s.startTime) / (BigInt(s.secPerBlock)*1000n);
}
function heightAfterDuration(h,durationMs){
  let remaining=durationMs/1000n,cur=h;
  for(let i=0;i<SEGMENTS.length;i++){const s=SEGMENTS[i];if(cur>s.endH)continue;
    const hStart=max(cur,s.startH),secsToEnd=(s.endH-hStart)*s.secPerBlock;
    if(remaining<=secsToEnd)return hStart+remaining/s.secPerBlock;remaining-=secsToEnd;cur=s.endH;}
  const last=SEGMENTS[SEGMENTS.length-1];return max(cur,last.endH)+remaining/last.secPerBlock;
}

const genTime=blockToTime(0);
const writtenTime=blockToTime(WRITTEN_HEIGHT);
function fmtDate(ms){const d=new Date(ms);const mo=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];return mo[d.getUTCMonth()]+" "+d.getUTCDate()+", "+d.getUTCFullYear();}

/* ================================================================
   Halving heights generator
   ================================================================ */
function halvingHeights(maxH){
    const result=[];
    let h=1_046_400n;
    while(h<=maxH){result.push(h);h+=1_680_000n;}
    return result;
}

/* ================================================================
   issuance_per_block() â€” zcash consensus
   ================================================================ */
function issuance_per_block(blockheight){
  const MAX_BLOCK_SUBSIDY=1250000000n,SLOW_START_INTERVAL=20000n,SLOW_START_SHIFT=10000n,
    SLOW_START_RATE=62500n,BLOSSOM_ACT=653600n,BLOSSOM_RATIO=2n,
    PRE_HALVING=840000n,POST_HALVING=1680000n;
  const h=BigInt(blockheight);
  if(blockheight<SLOW_START_SHIFT)return SLOW_START_RATE*h;
  if(blockheight<SLOW_START_INTERVAL)return SLOW_START_RATE*(h+1n);
  let halvings;
  if(blockheight>=BLOSSOM_ACT){const sc=BigInt(BLOSSOM_ACT-SLOW_START_SHIFT)*BLOSSOM_RATIO+(h-BigInt(BLOSSOM_ACT));halvings=Number(sc/POST_HALVING);}
  else halvings=Math.floor((blockheight-SLOW_START_SHIFT)/PRE_HALVING);
  if(halvings>=64n)return 0n;
  if(blockheight>=BLOSSOM_ACT)return(MAX_BLOCK_SUBSIDY/BLOSSOM_RATIO)>>BigInt(halvings);
  return MAX_BLOCK_SUBSIDY>>BigInt(halvings);
}

const G_MAX_SUB=1250000000n,G_SLOW_INT=20000n,G_SLOW_SHIFT=10000n,
  G_SLOW_RATE=62500n,G_BLOSSOM_H=653600n,G_RATIO=2n,G_POST_HALV=1680000n,G_HALV_OFF=633600n;

function sumArith(a,b){if(b<a)return 0n;const A=BigInt(a),B=BigInt(b),n=B-A+1n;return(A+B)*n/2n;}
function halvIdxPost(h){return (h+G_HALV_OFF)/G_POST_HALV;}  // BigInt division = floor
function nextHalvPost(h){return(halvIdxPost(h)+1n)*G_POST_HALV - G_HALV_OFF;}

function sumIssuanceRangeClean(startInc,endExc){
  if(endExc<=startInc)return 0n;let h=startInc,total=0n;
  while(h<endExc){
    if(h<G_SLOW_SHIFT){const e=min(endExc,G_SLOW_SHIFT);total+=G_SLOW_RATE*sumArith(h,e-1n);h=e;continue;}
    if(h<G_SLOW_INT){const e=min(endExc,G_SLOW_INT);total+=G_SLOW_RATE*sumArith(h+1n,e);h=e;continue;}
    if(h<G_BLOSSOM_H){const e=min(endExc,G_BLOSSOM_H);total+=G_MAX_SUB*BigInt(e-h);h=e;continue;}
    const k=halvIdxPost(h);if(k>=64n)break;
    const nxt=nextHalvPost(h),e=min(endExc,nxt);
    total+=(G_MAX_SUB/G_RATIO>>BigInt(k))*BigInt(e-h);h=e;
  }return total;
}

/* ================================================================
   Simulation engine
   ================================================================ */
const ZATOSHI=100_000_000n,SAMPLE_EVERY=1000n,SIM_BATCH=80_000n;
const MAX_MONEY_ZEC=21_000_000n;
const MAX_MONEY_ZAT = 2_100_000_000_000_000n;
const _kFloat = 1 - Math.pow(2, -1/1680000);
const ZIP234_K = _kFloat; // kept for test compat
const ZIP234_K_NUM = BigInt(Math.round(_kFloat * (2**32))) * (1n << 32n);
const ZIP234_K_SHIFT = 64n;
let zip234ActivationHeight=3_687_123n;

function defaultIssuanceZat(h, supZat, remZat) { return issuance_per_block(h); }
function zip234IssuanceZat(h, supZat, remZat) {
    if (h < zip234ActivationHeight) return issuance_per_block(h);
    return (remZat * ZIP234_K_NUM) >> ZIP234_K_SHIFT;
}

const scenarios={
    default:{fn:defaultIssuanceZat,data:[]},
    zip234:{fn:zip234IssuanceZat,data:[]}
};
let simVersion=0n,simRunning=false,simComputedVer=-1n,simComputedMaxH=-1n;

function fillAnnualPct(arr) {
    for (let i = 0; i < arr.length; i++) {
        const p = arr[i];
        if (p.supplyZat <= 0n || p.h < 20000n) continue;
        const targetH = heightAfterDuration(p.h, ONE_YEAR_MS);
        let lo = i + 1, hi = arr.length - 1;
        while (lo < hi) { const mid = (lo + hi) >> 1; arr[mid].h < targetH ? lo = mid + 1 : hi = mid; }
        if (lo >= arr.length) continue;
        const annIssZat = arr[lo].cumIssZat - p.cumIssZat;
        if (annIssZat >= 0n && p.supplyZat > 0n) {
            p.annualPctX1M = (annIssZat * 100_000_000n) / p.supplyZat;
            p.annualPctIsExpected = (arr[lo].h > WRITTEN_HEIGHT);
        }
    }
}

function lookupScenario(arr,h){
    if(!arr.length)return null;
    let lo=0,hi=arr.length-1;
    while(lo<hi){const mid=(lo+hi)>>1;arr[mid].h<h?lo=mid+1:hi=mid;}
    if(lo>0 && (h - arr[lo-1].h) < (arr[lo].h - h)) lo--;

    return arr[lo];
}

function invalidateSimulation(){
    simVersion++;simComputedVer=-1;computeAllScenarios();
}

function truncateScenarioData(name, fromH) {
    const d = scenarios[name].data;
    let keep = d.length;
    while (keep > 0 && d[keep - 1].h >= fromH) keep--;
    d.length = keep;
}

function invalidateScenarioFrom(name, fromH) {
    truncateScenarioData(name, fromH);
    invalidateSimulation();
}

function invalidateAllFrom(fromH) {
    for (const n of ['default', 'zip234']) truncateScenarioData(n, fromH);
    invalidateSimulation();
}

async function computeAllScenarios(){
    const neededH=max(0,timeToHeight(view.tMax+ONE_YEAR_MS)+10_000n);
    if(!simRunning&&simVersion===simComputedVer&&neededH<=simComputedMaxH)return;
    if(simRunning)return;
    simRunning=true;

    while(true){
        const myVer=simVersion;
        const maxH=max(0,timeToHeight(view.tMax+ONE_YEAR_MS)+10_000n);
        let cancelled=false;

        // Initialize per-scenario running state
        const names=['default','zip234'];
        const st={};
        for(const name of names){
            const result=scenarios[name].data,fn=scenarios[name].fn;
            let startH,supZat,cumIssZat,remZat;
            if(result.length>0){
                const last=result[result.length-1];
                startH=last.h+1;
                supZat=last.supplyZat;
                cumIssZat=last.cumIssZat;
                remZat=MAX_MONEY_ZAT-supZat;
            }else{
                startH=0;supZat=0n;cumIssZat=0n;remZat=MAX_MONEY_ZAT;
            }
            st[name]={result,fn,h:startH,supZat,cumIssZat,remZat};
        }

        // Advance both scenarios in lockstep batches
        while(!cancelled){
            let anyAdvanced=false;
            for(const name of names){
                const s=st[name];
                if(s.h>maxH)continue;
                anyAdvanced=true;
                const batchEnd=min(s.h+SIM_BATCH,maxH+1n);
                for(let h=s.h;h<batchEnd;h++){
                    for(const b of BURN_EVENTS){if(b.h===h){
                        const amt=b.zat<s.supZat?b.zat:s.supZat;
                        s.supZat-=amt;s.remZat+=amt;
                    }}
                    const issZat=s.fn(h,s.supZat,s.remZat);
                    s.supZat+=issZat;s.cumIssZat+=issZat;s.remZat-=issZat;
                    if(h%SAMPLE_EVERY===0n){
                        const spb=BigInt(h<BLOSSOM_ACTIVATION_HEIGHT?150n:75n);
                        s.result.push({
                            h,time:blockToTime(h),
                            supplyZat:s.supZat,
                            cumIssZat:s.cumIssZat,
                            issBlockZat:issZat,
                            issDayZat:issZat*86400n/spb,
                            annualPctX1M:-1n,
                            annualPctIsExpected:false
                        });
                    }
                }
                s.h=batchEnd;
            }
            if(!anyAdvanced)break;
            requestDraw();
            await new Promise(r=>setTimeout(r,0));
            if(simVersion!==myVer){cancelled=true;}
        }

        if(!cancelled&&simVersion===myVer){
            for(const name of names)fillAnnualPct(scenarios[name].data);
            simComputedVer=myVer;simComputedMaxH=maxH;break;
        }
    }
    simRunning=false;requestDraw();
}

/* ================================================================
   Burn event helpers
   ================================================================ */
function formatBurnLabel(zat, mode){
    const w=zat/100_000_000n,f=zat%100_000_000n;
    const u=mode==='perblock'?'â“©/blk':'â“©';
    if(f===0n){
        if(w>=1_000_000n&&w%1_000_000n===0n)return"Burn "+w/1_000_000n+"M "+u;
        if(w>=1_000n&&w%1_000n===0n)return"Burn "+w/1_000n+"K "+u;
    }
    return"Burn "+zatToZecString(zat)+" "+u;
}

function supplyAtHeightZat(h) { return sumIssuanceRangeClean(0, h); }

function changeBurn(newH=undefined, newZats=undefined, newMode=undefined){
    const b = BURN_EVENTS[0];
    const oldH = b.h;
    const oldZat = b.zat;
    const oldMode = b.mode;

    // Use current value if arg not provided
    const h = newH !== undefined ? clampBurnHeight(newH) : oldH;
    const mode = newMode !== undefined ? newMode : oldMode;
    const zat = newZats !== undefined ? newZats : oldZat;

    // Clamp: one-time burn can't exceed supply at that height
    const clampedZat = (mode === 'once')
        ? min(supplyAtHeightZat(h), zat)
        : zat;  // per-block is clamped each block in the sim loop

    // Skip if nothing changed
    if(h === oldH && clampedZat === oldZat && mode === oldMode) return;

    // Apply
    b.h = h;
    b.zat = clampedZat;
    b.mode = mode;
    b.label = formatBurnLabel(clampedZat, mode);

    // Invalidate from the earliest affected height
    const fromH = min(oldH, h);
    invalidateAllFrom(fromH);
    requestDraw();
}

/* ================================================================
   View state
   ================================================================ */
const MAX_TIME=Date.UTC(2100,0,1),MIN_SPAN=30*86400_000;
const view={tMin: genTime,tMax: blockToTime(6_000_000)};

function clampView(){
  let span=view.tMax-view.tMin;
  if(span<MIN_SPAN){const mid=(view.tMin+view.tMax)/2;view.tMin=mid-MIN_SPAN/2;view.tMax=mid+MIN_SPAN/2;span=MIN_SPAN;}
  if(view.tMin<genTime-2*ONE_YEAR_MS){view.tMax+=(genTime-2*ONE_YEAR_MS-view.tMin);view.tMin=genTime-2*ONE_YEAR_MS;}
  if(view.tMax>MAX_TIME){view.tMin-=(view.tMax-MAX_TIME);view.tMax=MAX_TIME;}
  if(view.tMin<genTime-2*ONE_YEAR_MS)view.tMin=genTime-2*ONE_YEAR_MS;
}

function resetView(){view.tMin=genTime;view.tMax=blockToTime(6_000_000);clampView();requestDraw();computeAllScenarios();}

function zoomToActivation(h){
  view.tMin=genTime;
  const endH=max(h*2n,h+100_000n);
  view.tMax=blockToTime(endH);
  clampView();requestDraw();computeAllScenarios();
}

/* ================================================================
   Right margin layout
   ================================================================ */
function computeRightMargin(isNarrow){
  if(isNarrow){if(show.supply)return 52;return 16;}
  return show.supply?70:20;
}

function rightAxisLayout(isNarrow){
  const r={supply:null};
  if(!show.supply)return r;
  if(isNarrow){r.supply={tickX:6,titleX:null};return r;}
  r.supply={tickX:6,titleX:50};
  return r;
}

function computeLeftMargin(isNarrow){
  if(isNarrow){if(show.issDay||show.annPct)return 52;return 16;}
  const AXIS_W=62;let count=0;if(show.issDay)count++;if(show.annPct)count++;
  return count===0?20:8+count*AXIS_W;
}

function leftAxisLayout(isNarrow){
  const r={issDay:null,annPct:null};
  if(isNarrow){if(show.issDay)r.issDay={tickX:6,titleX:null};else if(show.annPct)r.annPct={tickX:6,titleX:null};return r;}
  let off=6;
  if(show.issDay){r.issDay={tickX:off,titleX:off+44};off+=62;}
  if(show.annPct){r.annPct={tickX:off,titleX:off+44};off+=62;}
  return r;
}

/* ================================================================
   Drawing
   ================================================================ */
let drawRAF=null;const layout={};

function requestDraw(){if(!drawRAF)drawRAF=requestAnimationFrame(()=>{drawRAF=null;draw();});}

function draw(){
  if(!scenarios.default.data.length&&!scenarios.zip234.data.length)return;

  const canvas=document.getElementById("chart");
  const dpr=window.devicePixelRatio||1;
  const isNarrow=window.innerWidth<600;
  const CSS_W=min(960,window.innerWidth-20);
  const CSS_H=isNarrow?Math.round(CSS_W*0.62):Math.round(CSS_W*0.54);
  canvas.width=CSS_W*dpr;canvas.height=CSS_H*dpr;
  canvas.style.width=CSS_W+"px";canvas.style.height=CSS_H+"px";
  const ctx=canvas.getContext("2d");ctx.scale(dpr,dpr);

  const rightMar=computeRightMargin(isNarrow);
  const leftMar=computeLeftMargin(isNarrow);
  const MG={top:28,right:rightMar,bottom:52,left:leftMar};
  const PW=CSS_W-MG.left-MG.right,PH=CSS_H-MG.top-MG.bottom;
  Object.assign(layout,{CSS_W,CSS_H,MG,PW,PH});

  const axR=rightAxisLayout(isNarrow);
  const axL=leftAxisLayout(isNarrow);

  const T={bg:cv("--bg"),fg:cv("--fg"),muted:cv("--muted"),panel:cv("--panel"),
    supplyObs:cv("--supplyObs"),issObs:cv("--issObs"),supplyExp:cv("--supplyExp"),issExp:cv("--issExp"),
    annualObs:cv("--annualObs"),annualExp:cv("--annualExp"),
    eventObs:cv("--eventObs"),eventHalv:cv("--eventHalv"),written:cv("--written"),
    gridLine:cv("--gridLine"),capLine:cv("--capLine"),frameBorder:cv("--frameBorder"),
    zip234Supply:cv("--zip234Supply"),zip234Iss:cv("--zip234Iss"),zip234Ann:cv("--zip234Ann"),
    zip234Act:cv("--zip234Act"),
    burnEvent:cv("--burnEvent"),
    supplyFillObs:getTheme()==="dark"?"rgba(245,158,11,0.14)":"rgba(217,119,6,0.10)",
    supplyFillExp:getTheme()==="dark"?"rgba(245,158,11,0.06)":"rgba(217,119,6,0.05)",
    zip234FillObs: getTheme()==="dark" ? "rgba(56,189,248,0.12)" : "rgba(2,132,199,0.08)",
    zip234FillExp: getTheme()==="dark" ? "rgba(56,189,248,0.06)" : "rgba(2,132,199,0.04)",
  };

  ctx.fillStyle=T.panel;ctx.fillRect(0,0,CSS_W,CSS_H);

  const ySupMax=22_000_000,yIssDayMax=8_000,yAnnMax=30;
  const xP=t=>MG.left+((t-view.tMin)/(view.tMax-view.tMin))*PW;
  const ySP=s=>MG.top+PH-(s/ySupMax)*PH;
  const yIP=v=>MG.top+PH-(v/yIssDayMax)*PH;
  const yAP=p=>MG.top+PH-(p/yAnnMax)*PH;

  // Determine how much default data to show
  const defaultCutoffH = showDefaultFuture() ? 0x7FFFFFFFFFFFFFn : (showZip234() ? zip234ActivationHeight : WRITTEN_HEIGHT);
  const D=scenarios.default.data.filter(d=>d.time>=view.tMin&&d.time<=view.tMax&&d.h<=defaultCutoffH);

  // Grid
  if(show.supply){
    ctx.strokeStyle=T.gridLine;ctx.lineWidth=1;
    for(let s=0;s<=ySupMax;s+=3_000_000){ctx.beginPath();ctx.moveTo(MG.left,ySP(s));ctx.lineTo(MG.left+PW,ySP(s));ctx.stroke();}
  }

  // 21M cap
  if(show.supply){
    ctx.save();ctx.setLineDash([6,4]);ctx.strokeStyle=T.capLine;ctx.lineWidth=1;
    ctx.beginPath();ctx.moveTo(MG.left,ySP(21e6));ctx.lineTo(MG.left+PW,ySP(21e6));ctx.stroke();ctx.setLineDash([]);
    ctx.fillStyle=T.capLine;ctx.font="10px system-ui";ctx.textAlign="left";ctx.fillText("21 M cap",MG.left+4,ySP(21e6)-4);ctx.restore();
  }

  // Event verticals
  ctx.save();ctx.setLineDash([4,4]);ctx.lineWidth=1;

  // Blossom
  {const t=blockToTime(BLOSSOM_ACTIVATION_HEIGHT);
    if(t>=view.tMin&&t<=view.tMax){ctx.strokeStyle=T.eventObs;ctx.beginPath();ctx.moveTo(xP(t),MG.top);ctx.lineTo(xP(t),MG.top+PH);ctx.stroke();}}

  // Halvings (only up to defaultCutoffH)
  {const halvMax=defaultCutoffH===Infinity?timeToHeight(view.tMax)+200_000n:defaultCutoffH;
    for(const hh of halvingHeights(halvMax)){
      const t=blockToTime(hh);if(t>=view.tMin&&t<=view.tMax){ctx.strokeStyle=T.eventHalv;ctx.beginPath();ctx.moveTo(xP(t),MG.top);ctx.lineTo(xP(t),MG.top+PH);ctx.stroke();}}}

  // Written ("Sim written")
  {const t=writtenTime;if(t>=view.tMin&&t<=view.tMax){ctx.strokeStyle=T.written;ctx.lineWidth=1.5;ctx.beginPath();ctx.moveTo(xP(t),MG.top);ctx.lineTo(xP(t),MG.top+PH);ctx.stroke();}}

  // Burn events
  for(const b of BURN_EVENTS){const t=blockToTime(b.h);if(t>=view.tMin&&t<=view.tMax){ctx.strokeStyle=T.burnEvent;ctx.lineWidth=1.5;ctx.setLineDash([4,4]);ctx.beginPath();ctx.moveTo(xP(t),MG.top);ctx.lineTo(xP(t),MG.top+PH);ctx.stroke();}}

  // ZIP 234 activation
  if(showZip234()){
    const t=blockToTime(zip234ActivationHeight);
    if(t>=view.tMin&&t<=view.tMax){ctx.strokeStyle=T.zip234Act;ctx.lineWidth=1.5;ctx.setLineDash([6,3]);
      ctx.beginPath();ctx.moveTo(xP(t),MG.top);ctx.lineTo(xP(t),MG.top+PH);ctx.stroke();}
  }

  ctx.setLineDash([]);ctx.restore();

  // Clip to plot area
  ctx.save();ctx.beginPath();ctx.rect(MG.left,MG.top,PW,PH);ctx.clip();

  // Helper: draw split line (observed solid / expected dashed)
  function drawSplit(pts,splitH,yFn,obsC,expC,lw){
    ctx.beginPath();ctx.strokeStyle=obsC;ctx.lineWidth=lw;ctx.setLineDash([]);
    let started=false;
    for(const p of pts){if(p.h>splitH)break;const py=yFn(p);if(!isFinite(py))continue;
      const px=xP(p.time);if(!started){ctx.moveTo(px,py);started=true;}else ctx.lineTo(px,py);}
    ctx.stroke();
    ctx.beginPath();ctx.strokeStyle=expC;ctx.lineWidth=lw;ctx.setLineDash([6,4]);started=false;
    for(const p of pts){if(p.h<splitH){const py=yFn(p);if(!isFinite(py))continue;ctx.moveTo(xP(p.time),py);started=true;continue;}
      const py=yFn(p);if(!isFinite(py))continue;const px=xP(p.time);
      if(!started){ctx.moveTo(px,py);started=true;}else ctx.lineTo(px,py);}
    ctx.stroke();ctx.setLineDash([]);
  }
  // Helper: fill under supply curve
  function fillAreaAlways(pts,yFn,color){
    if(pts.length<2)return;
    ctx.beginPath();
    ctx.moveTo(xP(pts[0].time),ySP(0));
    for(const p of pts){const py=yFn(p);if(isFinite(py))ctx.lineTo(xP(p.time),py);}
    ctx.lineTo(xP(pts[pts.length-1].time),ySP(0));
    ctx.closePath();ctx.fillStyle=color;ctx.fill();
  }

  const ANNUAL_PCT_SPLIT_HEIGHT = WRITTEN_HEIGHT - ONE_YEAR_MS / 1000n / (WRITTEN_HEIGHT < 653600n ? 150n : 75n);

  // Default model curves
  if(D.length>=2){
    if(show.supply){
        fillAreaAlways(D,p=>ySP(zatToZec(p.supplyZat)),T.supplyFillObs);
        drawSplit(D,WRITTEN_HEIGHT,p=>ySP(zatToZec(p.supplyZat)),T.supplyObs,T.supplyExp,2);
    }
    if(show.issDay)drawSplit(D,WRITTEN_HEIGHT,p=>yIP(zatToZec(p.issDayZat),T.issObs,T.issExp,2));
    if(show.annPct)drawSplit(D,ANNUAL_PCT_SPLIT_HEIGHT,p=>{const v=annPctVal(p);if(!isFinite(v)||v>200)return NaN;return yAP(v);},T.annualObs,T.annualExp,1.8);
  }

  // ZIP 234 curves
  if(showZip234()&&scenarios.zip234.data.length>=1){
    const Z=scenarios.zip234.data.filter(d=>d.time>=view.tMin&&d.time<=view.tMax&&d.h>=zip234ActivationHeight);
    if(show.supply&&Z.length>=2){
      fillAreaAlways(Z,p=>ySP(zatToZec(p.supplyZat)),T.zip234FillObs);
    }

    function drawZ234Line(yFn,color,lw){
      if(Z.length<1)return;ctx.beginPath();ctx.setLineDash([6,4]);ctx.strokeStyle=color;ctx.lineWidth=lw;
      let started=false;for(const p of Z){const py=yFn(p);if(!isFinite(py))continue;
        const px=xP(p.time);if(!started){ctx.moveTo(px,py);started=true;}else ctx.lineTo(px,py);}
      ctx.stroke();ctx.setLineDash([]);
    }

    if(show.supply)drawZ234Line(p=>ySP(zatToZec(p.supplyZat)),T.zip234Supply,2.5);
      if(show.issDay)drawZ234Line(p=>yIP(zatToZec(p.issDayZat)),T.zip234Iss,2.5);
    if(show.annPct)drawZ234Line(p=>{const v=annPctVal(p);if(!isFinite(v)||v>200)return NaN;return yAP(v);},T.zip234Ann,1.8);
  }

  ctx.restore();// end clip

  // Event labels
  ctx.font="9px system-ui";
  const mo=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
  function eventLabel(h,label,color){
    const t=blockToTime(h);if(t<view.tMin||t>view.tMax)return;
    ctx.fillStyle=color;ctx.save();ctx.translate(xP(t)-2,MG.top+PH-4);ctx.rotate(-Math.PI/2);
    ctx.textAlign="left";ctx.fillText(label+" â€” "+mo[new Date(t).getUTCMonth()]+" "+new Date(t).getUTCFullYear(),0,0);ctx.restore();
  }

  eventLabel(BLOSSOM_ACTIVATION_HEIGHT,"Blossom",T.eventObs);
  {const halvMax=defaultCutoffH===Infinity?timeToHeight(view.tMax)+200_000n:defaultCutoffH;
    for(const hh of halvingHeights(halvMax)){
      const idx=Number((hh-1_046_400n)/1_680_000n)+1;eventLabel(hh,"Halving "+idx,T.eventHalv);}}

  // "Sim written" label
  {const t=writtenTime;if(t>=view.tMin&&t<=view.tMax){ctx.fillStyle=T.written;ctx.save();ctx.translate(xP(t)-2,MG.top+PH-4);ctx.rotate(-Math.PI/2);ctx.textAlign="left";ctx.fillText("Sim written",0,0);ctx.restore();}}

  // Burn event labels
  for(const b of BURN_EVENTS){const t=blockToTime(b.h);if(t>=view.tMin&&t<=view.tMax){ctx.fillStyle=cv("--burnEvent");ctx.save();ctx.translate(xP(t)-2,MG.top+PH-4);ctx.rotate(-Math.PI/2);ctx.textAlign="left";ctx.font="9px system-ui";ctx.fillText(b.label,0,0);ctx.restore();}}

  // ZIP 234 activation label
    if(showZip234()){const t=blockToTime(zip234ActivationHeight);if(t>=view.tMin&&t<=view.tMax){
    ctx.fillStyle=T.zip234Act;ctx.save();ctx.translate(xP(t)-2,MG.top+PH-4);ctx.rotate(-Math.PI/2);
    ctx.textAlign="left";ctx.font="9px system-ui";ctx.fillText("ZIP 234 activation",0,0);ctx.restore();}}

  // Left axis 1 (Issuance/Day)
  if(show.issDay&&axL.issDay){const ax=axL.issDay,bx=MG.left-ax.tickX;
    ctx.fillStyle=T.issObs;ctx.font="11px system-ui";ctx.textAlign="right";
    for(let v=0;v<=yIssDayMax;v+=2_000){const lb=isNarrow?(v>=1000?(v/1000)+"k":String(v)):v.toLocaleString();ctx.fillText(lb,bx,yIP(v)+4);}
    if(!isNarrow&&ax.titleX!=null){ctx.save();ctx.translate(MG.left-ax.titleX,MG.top+PH/2);ctx.rotate(-Math.PI/2);
      ctx.fillStyle=T.issObs;ctx.font="12px system-ui";ctx.textAlign="center";ctx.fillText("Issuance per Day (â“©)",0,0);ctx.restore();}}

  // Left axis 2 (Annual %)
  if(show.annPct&&axL.annPct){const ax=axL.annPct,bx=MG.left-ax.tickX;
    ctx.fillStyle=T.annualObs;ctx.font="10px system-ui";ctx.textAlign="right";
    for(let p=0;p<=yAnnMax;p+=5)ctx.fillText(p+"%",bx,yAP(p)+3);
    if(!isNarrow&&ax.titleX!=null){ctx.save();ctx.translate(MG.left-ax.titleX,MG.top+PH/2);ctx.rotate(-Math.PI/2);
      ctx.fillStyle=T.annualObs;ctx.font="11px system-ui";ctx.textAlign="center";ctx.fillText("Annualized Issuance %",0,0);ctx.restore();}}

  // Right axis (Supply)
  if(show.supply&&axR.supply){const ax=axR.supply,bx=MG.left+PW+ax.tickX;
    ctx.fillStyle=T.supplyObs;ctx.font="11px system-ui";ctx.textAlign="left";
    for(let s=0;s<=ySupMax;s+=3_000_000)ctx.fillText((s/1e6).toFixed(0)+" M",bx,ySP(s)+4);
    if(!isNarrow&&ax.titleX!=null){ctx.save();ctx.translate(MG.left+PW+ax.titleX,MG.top+PH/2);ctx.rotate(Math.PI/2);
      ctx.fillStyle=T.supplyObs;ctx.font="12px system-ui";ctx.textAlign="center";ctx.fillText("Cumulative Supply (â“©)",0,0);ctx.restore();}}

  // X axis
  ctx.fillStyle=T.muted;ctx.font="10px system-ui";ctx.textAlign="center";
  const maxViewH=timeToHeight(view.tMax)+200_000n;
  const allHalvings=halvingHeights(maxViewH);
  for(const hh of allHalvings){
    const t=blockToTime(hh);
    if(t<view.tMin||t>view.tMax)continue;
    const d=new Date(t);
    const label=mo[d.getUTCMonth()]+" "+d.getUTCFullYear();
    ctx.fillText(label,xP(t),MG.top+PH+20);
    ctx.strokeStyle=T.gridLine;ctx.lineWidth=1;
    ctx.beginPath();ctx.moveTo(xP(t),MG.top+PH);ctx.lineTo(xP(t),MG.top+PH+4);ctx.stroke();
  }
  ctx.font="12px system-ui";ctx.fillText("Date (UTC)",MG.left+PW/2,MG.top+PH+42);

  // Frame
  ctx.strokeStyle=T.frameBorder;ctx.lineWidth=1;ctx.strokeRect(MG.left,MG.top,PW,PH);

  // Position activation handle
  updateActHandle();
  // Position burn handle
  updateBurnHandle();
}

/* ================================================================
   Activation handle geometry helpers
   ================================================================ */
function computeStemHeightFromBottom(visibleBottomInWrap, plotTop, minHeight=4){
  return max(minHeight, plotTop - visibleBottomInWrap);
}

function measureActHandleGeometry({ actHandle, wrapEl, actCollapsed, MG }){
  // Apply state before measuring so we measure the actual visible element
  actHandle.classList.toggle("collapsed", actCollapsed);
  actHandle.offsetHeight; // force layout

  const visibleEl = actCollapsed
    ? actHandle.querySelector(".act-nub")
    : actHandle.querySelector(".act-pill");

  const visibleRect = visibleEl.getBoundingClientRect();
  const wrapRect = wrapEl.getBoundingClientRect();

  const visibleBottomInWrap = visibleRect.bottom - wrapRect.top;
  const stemHeight = computeStemHeightFromBottom(visibleBottomInWrap, MG.top);

  return { visibleBottomInWrap, stemHeight };
}
 
/* ================================================================
   Activation handle positioning
   ================================================================ */
const actHandle=document.getElementById("actHandle");
const actBlockInput=document.getElementById("actBlockInput");
const actDateInput=document.getElementById("actDateInput");

function updateActHandle(){
    if(!showZip234()){actHandle.style.display="none";return null;}
    const{CSS_W,CSS_H,MG,PW,PH}=layout;
    if(!PW){actHandle.style.display="none";return null;}
    const t=blockToTime(zip234ActivationHeight);
    if(t<view.tMin||t>view.tMax){actHandle.style.display="none";return null;}
    const frac=(t-view.tMin)/(view.tMax-view.tMin);
    const xPx=MG.left+frac*PW;
    actHandle.style.display="block";
    actHandle.style.left=xPx+"px";
    // Apply collapsed state
    actHandle.classList.toggle("collapsed", actCollapsed);
    // Zero out stem and reset top before measuring
    const stem=actHandle.querySelector('.act-stem');
    stem.style.height="0px";
    actHandle.style.top="0px";
    actHandle.offsetHeight;
    // Center the visible element at y=0 (top of chart-wrap)
    const visibleEl=actCollapsed
      ? actHandle.querySelector('.act-nub')
      : actHandle.querySelector('.act-pill');
    const visH=visibleEl.offsetHeight;
    actHandle.style.top=(-visH/2)+"px";
    actHandle.offsetHeight;
    // Measure where content ends
    const wrapEl=document.getElementById("chartWrap");
    const wrapRect=wrapEl.getBoundingClientRect();
    const handleRect=actHandle.getBoundingClientRect();
    const handleBottom=handleRect.bottom-wrapRect.top;
    // Stem reaches the 21M cap line (ySupMax is 22M, so capY = MG.top + PH/22)
    const capLineY=MG.top+PH-(21_000_000/22_000_000)*PH;
    const stemHeight=max(0, capLineY-handleBottom);
    stem.style.height=stemHeight+"px";
    actBlockInput.value=zip234ActivationHeight.toLocaleString();
    actDateInput.value=fmtDate(blockToTime(zip234ActivationHeight));
    return {stemHeight};
}

/* ================================================================
   Burn handle state & positioning
   ================================================================ */
const burnHandle=document.getElementById("burnHandle");
const burnBlockInput=document.getElementById("burnBlockInput");
const burnDateInput=document.getElementById("burnDateInput");
const burnAmtInput=document.getElementById("burnAmtInput");
let burnCollapsed=false;

function clampBurnHeight(h){
    return max(WRITTEN_HEIGHT, h);
}

function updateBurnHandle(){
    if(!burnHandle)return null;
    const{CSS_W,CSS_H,MG,PW,PH}=layout;
    if(!PW){burnHandle.style.display="none";return null;}
    const b=BURN_EVENTS[0];
    if(!b){burnHandle.style.display="none";return null;}
    const t=blockToTime(b.h);
    if(t<view.tMin||t>view.tMax){burnHandle.style.display="none";return null;}
    const frac=(t-view.tMin)/(view.tMax-view.tMin);
    const xPx=MG.left+frac*PW;
    burnHandle.style.display="block";
    burnHandle.style.left=xPx+"px";
    burnHandle.classList.toggle("collapsed",burnCollapsed);
    const stem=burnHandle.querySelector('.burn-stem');
    stem.style.height="0px";
    burnHandle.style.top="0px";
    burnHandle.offsetHeight;
    const visibleEl=burnCollapsed
      ? burnHandle.querySelector('.burn-nub')
      : burnHandle.querySelector('.burn-pill');
    const visH=visibleEl.offsetHeight;
    burnHandle.style.top=(-visH/2)+"px";
    burnHandle.offsetHeight;
    const wrapEl=document.getElementById("chartWrap");
    const wrapRect=wrapEl.getBoundingClientRect();
    const handleRect=burnHandle.getBoundingClientRect();
    const handleBottom=handleRect.bottom-wrapRect.top;
    const capLineY=MG.top+PH-(21_000_000/22_000_000)*PH;
    const stemHeight=max(0,capLineY-handleBottom);
    stem.style.height=stemHeight+"px";
    burnBlockInput.value=b.h.toLocaleString();
    burnDateInput.value=fmtDate(blockToTime(b.h));
    burnAmtInput.value = zatToZecString(b.zat);

    document.querySelectorAll('#burnModeGroup .burn-mode-btn').forEach(b=>
        b.classList.toggle('active', b.dataset.burnMode === BURN_EVENTS[0].mode));

    return {stemHeight};
}
    
/* ================================================================
   Extracted handler: activation drag (shared by mouse & touch)
   ================================================================ */
function handleActDrag(clientX){
  const adjustedX=clientX-actDragOffsetX;
  const canvasEl=document.getElementById("chart");
  const rect=canvasEl.getBoundingClientRect();
  const{MG,PW}=layout;
  const cssW=parseInt(canvasEl.style.width);
  const mx=(adjustedX-rect.left)*(cssW/rect.width);
  const frac=max(0,min(1,(mx-MG.left)/PW));
  const t=view.tMin+frac*(view.tMax-view.tMin);
  changeZIP234ActivationHeight(timeToHeight(t));
}

function changeZIP234ActivationHeight(newH) {
    const clampedH = max(newH, WRITTEN_HEIGHT);
    const oldH = zip234ActivationHeight;
    if (oldH !== clampedH) {
        zip234ActivationHeight = clampedH;
        invalidateScenarioFrom('zip234', min(oldH, clampedH));
        requestDraw();
    }
}

/* ================================================================
   Extracted handler: activation block input
   ================================================================ */
function handleActBlockInput(){
  const raw=actBlockInput.value.replace(/,/g,"").trim();
  const v=parseInt(raw);
  if(!isNaN(v)&&v>=0){
      changeZIP234ActivationHeight(v);
      zoomToActivation(zip234ActivationHeight);
  }
  actBlockInput.blur();
}

/* ================================================================
   Extracted handler: activation date input
   ================================================================ */
function handleActDateInput(){
  const raw=actDateInput.value.trim();
  const parsed=Date.parse(raw);
  if(!isNaN(parsed)){
      changeZIP234ActivationHeight(timeToHeight(parsed));
      zoomToActivation(zip234ActivationHeight);
  }
  actDateInput.blur();
}

/* ================================================================
   Extracted handler: burn drag (shared by mouse & touch)
   ================================================================ */
let burnDragging=false,burnDragOffsetX=0;

function handleBurnDrag(clientX) {
    const adjustedX = clientX - burnDragOffsetX;
    const canvasEl = document.getElementById("chart");
    const rect = canvasEl.getBoundingClientRect();
    const {MG, PW} = layout;
    const cssW = parseInt(canvasEl.style.width);
    const mx = (adjustedX - rect.left) * (cssW / rect.width);
    const frac = max(0, min(1, (mx - MG.left) / PW));
    const t = view.tMin + frac * (view.tMax - view.tMin);
    changeBurn(timeToHeight(t));
}

/* ================================================================
   Extracted handler: burn block input
   ================================================================ */
function handleBurnBlockInput() {
    const raw = burnBlockInput.value.replace(/,/g, "").trim();
    changeBurn(BigInt(raw));
    burnBlockInput.blur();
}

function min(a, b) { return a < b ? a : b; }
function max(a, b) { return a > b ? a : b; }

/* ================================================================
   Extracted handler: burn date input
   ================================================================ */
function handleBurnDateInput() {
    const raw = burnDateInput.value.trim();
    const parsed = Date.parse(raw);
    if (!isNaN(parsed)) {
        changeBurn(timeToHeight(parsed));
    }
    burnDateInput.blur();
}

/* ================================================================
   Extracted handler: burn amount input
   ================================================================ */
function handleBurnAmtInput() {
    changeBurn(undefined, parseZecToZat(burnAmtInput.value));
    burnAmtInput.blur();
}

/* ================================================================
   Extracted handler: chart drag
   ================================================================ */
let dragging=false,dragStartX=0,dragStartTMin=0,dragStartTMax=0;

function handleChartDragStart(clientX){
  dragging=true;dragStartX=clientX;dragStartTMin=view.tMin;dragStartTMax=view.tMax;
  document.getElementById("chart").style.cursor="grabbing";
}

function handleChartDragMove(clientX){
  const rect=document.getElementById("chart").getBoundingClientRect();
  const dx=clientX-dragStartX;
  const pxPerMs=(dragStartTMax-dragStartTMin)/rect.width;
  view.tMin=dragStartTMin-dx*pxPerMs;view.tMax=dragStartTMax-dx*pxPerMs;
  clampView();requestDraw();computeAllScenarios();
}

/* ================================================================
   Extracted handler: chart wheel (zoom/pan)
   ================================================================ */
function handleChartWheel(e){
  e.preventDefault();
  const rect=document.getElementById("chart").getBoundingClientRect();
  const frac=(e.clientX-rect.left)/rect.width;
  if(e.ctrlKey||e.metaKey||Math.abs(e.deltaY)>50&&Math.abs(e.deltaX)<5){
    const zf=Math.pow(1.002,e.deltaY),span=view.tMax-view.tMin,pivot=view.tMin+frac*span;
    view.tMin=pivot-(pivot-view.tMin)*zf;view.tMax=pivot+(view.tMax-pivot)*zf;
  }else{const shift=(e.deltaX||e.deltaY)*(view.tMax-view.tMin)*0.001;view.tMin+=shift;view.tMax+=shift;}
  clampView();requestDraw();computeAllScenarios();
}

/* ================================================================
   Extracted handler: legend toggle
   ================================================================ */
function handleLegendToggle(el) {
    const key = el.dataset.series;
    show[key] = !show[key];
    el.classList.toggle('active', show[key]);
    requestDraw();
}

/* ================================================================
   Extracted handler: chart hover (tooltip)
   ================================================================ */
function handleChartHover(e){
  const tooltip=document.getElementById("tooltip");
  const writtenTipEl=document.getElementById("writtenTip");
  const tooltipData=scenarios.default.data.length>=2?scenarios.default.data:scenarios.zip234.data;
  if(dragging||actDragging||burnDragging||tooltipData.length<2){tooltip.style.display="none";writtenTipEl.style.display="none";return;}
  const canvasEl=document.getElementById("chart");
  const rect=canvasEl.getBoundingClientRect();
  const cssW=parseInt(canvasEl.style.width),cssH=parseInt(canvasEl.style.height);
  const{MG,PW,PH}=layout;if(!PW){tooltip.style.display="none";return;}
  const mx=(e.clientX-rect.left)*(cssW/rect.width),my=(e.clientY-rect.top)*(cssH/rect.height);

  // Written tooltip + Burn event tooltips
  let specialTipShown=false;
  const wt=writtenTime;
  if(wt>=view.tMin&&wt<=view.tMax){
    const wx=MG.left+((wt-view.tMin)/(view.tMax-view.tMin))*PW;
    if(Math.abs(mx-wx)<12&&my>=MG.top&&my<=MG.top+PH){
      writtenTipEl.innerHTML='This is when this simulation was written.<br>Data before this line is <b>observed</b>; after is <b>expected</b>.';
      writtenTipEl.style.display="block";
      const tipScreenX=rect.left+(wx/cssW)*rect.width;
      const tipScreenY=rect.top+((MG.top+PH+6)/cssH)*rect.height;
      writtenTipEl.style.left=tipScreenX+"px";
      writtenTipEl.style.top=tipScreenY+"px";
      specialTipShown=true;
    }
  }
  if(!specialTipShown){
    for(const b of BURN_EVENTS){
      const bt=blockToTime(b.h);
      if(bt>=view.tMin&&bt<=view.tMax){
        const bx=MG.left+((bt-view.tMin)/(view.tMax-view.tMin))*PW;
        if(Math.abs(mx-bx)<12&&my>=MG.top&&my<=MG.top+PH){
          writtenTipEl.innerHTML=`<b style="color:var(--burnEvent)">${b.label}</b><br>Block ${b.h.toLocaleString()}<br>${fmtDate(bt)} (UTC)<br>${zatToZecString(b.zat).toLocaleString()} â“© burned`;
          writtenTipEl.style.display="block";
          const tipScreenX=rect.left+(bx/cssW)*rect.width;
          const tipScreenY=rect.top+((MG.top+PH+6)/cssH)*rect.height;
          writtenTipEl.style.left=tipScreenX+"px";
          writtenTipEl.style.top=tipScreenY+"px";
          specialTipShown=true;
          break;
        }
      }
    }
  }
  if(!specialTipShown)writtenTipEl.style.display="none";

  if(mx<MG.left||mx>MG.left+PW||my<MG.top||my>MG.top+PH){tooltip.style.display="none";return;}
  const mouseTime=view.tMin+((mx-MG.left)/PW)*(view.tMax-view.tMin);

  let lo=0,hi=tooltipData.length-1;
  while(lo<hi){const mid=(lo+hi)>>1;tooltipData[mid].time<mouseTime?lo=mid+1:hi=mid;}
  if(lo>0&&Math.abs(tooltipData[lo-1].time-mouseTime)<Math.abs(tooltipData[lo].time-mouseTime))lo--;
  const d=tooltipData[lo];

  const isExp=d.h>WRITTEN_HEIGHT,status=isExp?"Expected":"Observed",sc=isExp?"tt-exp":"tt-obs";
    const pct=(zatToZec(d.supplyZat)/21e6*100);
  const annStatus=d.annualPctIsExpected?"expected":"observed";
    const annVal=isFinite(annPctVal(d))?annPctVal(d).toFixed(2)+"%":"â€”";
  const annColor=d.annualPctIsExpected?"var(--annualExp)":"var(--annualObs)";

  let html=`<div><b>Block ${d.h.toLocaleString()}</b> Â· <span class="${sc}">${status}</span></div>`+
    `<div class="tt-muted">${fmtDate(d.time)} (UTC)</div>`;

    const defaultCutoffH2=showDefaultFuture()?Infinity:(showZip234()?zip234ActivationHeight:-1);
  const showDefHere=d.h<=defaultCutoffH2;

  if(showDefHere){
    if(show.supply)html+=`<div style="margin-top:6px"><span style="color:var(--supplyObs)">Supply:</span> ${zatToZec(d.supplyZat).toLocaleString(undefined,{maximumFractionDigits:2})} â“© <span class="tt-muted">(${pct.toFixed(2)}% of cap)</span></div>`;
      if(show.issDay)html+=`<div><span style="color:var(--issObs)">Issuance:</span> ${zatToZec(d.issDayZat).toLocaleString(undefined,{maximumFractionDigits:1})} â“©/day</div><div class="tt-muted">Per block: ${zatToZec(d.issBlockZat).toFixed(8)} â“©</div>`;
    if(show.annPct)html+=`<div><span style="color:${annColor}">Annual:</span> ${annVal} <span class="tt-muted">(${annStatus})</span></div>`;
  }

  if(showZip234()&&d.h>=zip234ActivationHeight){
    const z=lookupScenario(scenarios.zip234.data,d.h);
    if(z){
      html+=`<div style="margin-top:6px;border-top:1px solid rgba(148,163,184,0.2);padding-top:4px"><b style="color:var(--zip234Supply)">ZIP 234 (smooth):</b></div>`;
        if(show.supply){const zp=(zatToZec(z.supplyZat)/21e6*100);html+=`<div><span style="color:var(--zip234Supply)">Supply:</span> ${zatToZec(z.supplyZat).toLocaleString(undefined,{maximumFractionDigits:2})} â“© <span class="tt-muted">(${zp.toFixed(2)}%)</span></div>`;}
        if(show.issDay)html+=`<div><span style="color:var(--zip234Iss)">Issuance:</span> ${zatToZec(z.issDayZat).toLocaleString(undefined,{maximumFractionDigits:1})} â“©/day</div><div class="tt-muted">Per block: ${zatToZec(z.issBlockZat).toFixed(8)} â“©</div>`;
        if(show.annPct){const av=isFinite(annualPctVal(z))?annualPctVal(z).toFixed(2)+"%":"â€”";html+=`<div><span style="color:var(--zip234Ann)">Annual:</span> ${av}</div>`;}
    }
  }else if(showZip234()&&d.h<zip234ActivationHeight){
    html+=`<div style="margin-top:4px" class="tt-muted"><i>ZIP 234 activates at block ${zip234ActivationHeight.toLocaleString()}</i></div>`;
  }

  tooltip.innerHTML=html;tooltip.style.display="block";
  const tipW=min(400,window.innerWidth-20);
  tooltip.style.left=min(e.clientX+14,window.innerWidth-tipW-10)+"px";
  tooltip.style.top=max(10,e.clientY-130)+"px";
}

/* ================================================================
   Wire up event listeners (thin wrappers calling named functions)
   ================================================================ */
const canvas=document.getElementById("chart");
const tooltip=document.getElementById("tooltip");
const writtenTip=document.getElementById("writtenTip");
let actDragging=false, actDragOffsetX=0;

// --- Activation handle: mouse drag ---
let actPointerStart = { x: 0, y: 0, time: 0 };

actHandle.addEventListener("mousedown",e=>{
    if(e.target.tagName==="INPUT")return;
    actDragging=true;
    const hr=actHandle.getBoundingClientRect();
    actDragOffsetX=e.clientX-(hr.left+hr.right)/2;
    actPointerStart={x: e.clientX,y: e.clientY,time: Date.now()};
    e.preventDefault();
    e.stopPropagation();
});

window.addEventListener("mouseup", e => {
  if (actDragging) {
    const dx = Math.abs(e.clientX - actPointerStart.x);
    const dt = Date.now() - actPointerStart.time;
    // If barely moved and quick, it's a click â†’ toggle collapsed
    if (dx < 4 && dt < 300) {
      actCollapsed = !actCollapsed;
      requestDraw();
    }
    actDragging = false;
  }
});

window.addEventListener("mousemove",e=>{
  if(!actDragging)return;
  handleActDrag(e.clientX);
});

// --- Activation handle: touch drag ---
actHandle.addEventListener("touchstart",e=>{
    if(e.target.tagName==="INPUT")return;
    actDragging=true;
    const t=e.touches[0];
    const hr=actHandle.getBoundingClientRect();
    actDragOffsetX=t.clientX-(hr.left+hr.right)/2;
    actPointerStart={x: t.clientX,y: t.clientY,time: Date.now()};
    e.stopPropagation();
},{passive: true});

window.addEventListener("touchend", e => {
  if (actDragging) {
    const cx = e.changedTouches?.[0]?.clientX ?? actPointerStart.x;
    const dx = Math.abs(cx - actPointerStart.x);
    const dt = Date.now() - actPointerStart.time;
    if (dx < 4 && dt < 300) {
      actCollapsed = !actCollapsed;
      requestDraw();
    }
    actDragging = false;
  }
});

window.addEventListener("touchmove",e=>{
  if(!actDragging)return;
  handleActDrag(e.touches[0].clientX);
},{passive:true});

// --- Activation handle: block input ---
actBlockInput.addEventListener("keydown",e=>{
  if(e.key==="Enter"){handleActBlockInput();}
  e.stopPropagation();
});
actBlockInput.addEventListener("mousedown",e=>e.stopPropagation());
actBlockInput.addEventListener("click",e=>e.stopPropagation());

// --- Activation handle: date input ---
actDateInput.addEventListener("keydown",e=>{
  if(e.key==="Enter"){handleActDateInput();}
  e.stopPropagation();
});
actDateInput.addEventListener("mousedown",e=>e.stopPropagation());
actDateInput.addEventListener("click",e=>e.stopPropagation());

// --- Burn handle: mouse drag ---
let burnPointerStart={x:0,y:0,time:0};
burnHandle.addEventListener("mousedown",e=>{
    if(e.target.tagName==="INPUT")return;
    burnDragging=true;
    const hr=burnHandle.getBoundingClientRect();
    burnDragOffsetX=e.clientX-(hr.left+hr.right)/2;
    burnPointerStart={x:e.clientX,y:e.clientY,time:Date.now()};
    e.preventDefault();
    e.stopPropagation();
});
window.addEventListener("mouseup",e=>{
    if(burnDragging){
        const dx=Math.abs(e.clientX-burnPointerStart.x);
        const dt=Date.now()-burnPointerStart.time;
        if(dx<4&&dt<300){burnCollapsed=!burnCollapsed;requestDraw();}
        burnDragging=false;
    }
});
window.addEventListener("mousemove",e=>{
    if(!burnDragging)return;
    handleBurnDrag(e.clientX);
});
// --- Burn handle: touch drag ---
burnHandle.addEventListener("touchstart",e=>{
    if(e.target.tagName==="INPUT")return;
    burnDragging=true;
    const t=e.touches[0];
    const hr=burnHandle.getBoundingClientRect();
    burnDragOffsetX=t.clientX-(hr.left+hr.right)/2;
    burnPointerStart={x:t.clientX,y:t.clientY,time:Date.now()};
    e.stopPropagation();
},{passive:true});
window.addEventListener("touchend",e=>{
    if(burnDragging){
        const cx=e.changedTouches?.[0]?.clientX??burnPointerStart.x;
        const dx=Math.abs(cx-burnPointerStart.x);
        const dt=Date.now()-burnPointerStart.time;
        if(dx<4&&dt<300){burnCollapsed=!burnCollapsed;requestDraw();}
        burnDragging=false;
    }
});
window.addEventListener("touchmove",e=>{
    if(!burnDragging)return;
    handleBurnDrag(e.touches[0].clientX);
},{passive:true});
// --- Burn handle: block input ---
burnBlockInput.addEventListener("keydown",e=>{
    if(e.key==="Enter"){handleBurnBlockInput();}
    e.stopPropagation();
});
burnBlockInput.addEventListener("mousedown",e=>e.stopPropagation());
burnBlockInput.addEventListener("click",e=>e.stopPropagation());
// --- Burn handle: date input ---
burnDateInput.addEventListener("keydown",e=>{
    if(e.key==="Enter"){handleBurnDateInput();}
    e.stopPropagation();
});
burnDateInput.addEventListener("mousedown",e=>e.stopPropagation());
burnDateInput.addEventListener("click",e=>e.stopPropagation());
// --- Burn handle: amount input ---
burnAmtInput.addEventListener("keydown",e=>{
    if(e.key==="Enter"){handleBurnAmtInput();}
    e.stopPropagation();
});
burnAmtInput.addEventListener("mousedown",e=>e.stopPropagation());
burnAmtInput.addEventListener("click",e=>e.stopPropagation());

// --- Chart: mouse drag ---
canvas.addEventListener("mousedown",e=>{if(actDragging||burnDragging)return;handleChartDragStart(e.clientX);});
window.addEventListener("mousemove",e=>{if(!dragging||actDragging||burnDragging)return;handleChartDragMove(e.clientX);});
window.addEventListener("mouseup",()=>{dragging=false;canvas.style.cursor="crosshair";});

// --- Chart: wheel ---
canvas.addEventListener("wheel",handleChartWheel,{passive:false});

// --- Chart: double-click ---
canvas.addEventListener("dblclick",()=>resetView());

// --- Chart: touch pan/zoom ---
let lastTouchDist=0;
canvas.addEventListener("touchstart",e=>{if(e.touches.length===1){handleChartDragStart(e.touches[0].clientX);}
  else if(e.touches.length===2){dragging=false;lastTouchDist=Math.abs(e.touches[0].clientX-e.touches[1].clientX);}},{passive:true});
canvas.addEventListener("touchmove",e=>{if(e.touches.length===1&&dragging&&!actDragging){handleChartDragMove(e.touches[0].clientX);}
  else if(e.touches.length===2){const dist=Math.abs(e.touches[0].clientX-e.touches[1].clientX),mid=(e.touches[0].clientX+e.touches[1].clientX)/2;
    if(lastTouchDist>0){const zf=lastTouchDist/dist,rect=canvas.getBoundingClientRect(),frac=(mid-rect.left)/rect.width,
      span=view.tMax-view.tMin,pivot=view.tMin+frac*span;view.tMin=pivot-(pivot-view.tMin)*zf;view.tMax=pivot+(view.tMax-pivot)*zf;
      clampView();requestDraw();computeAllScenarios();}lastTouchDist=dist;}},{passive:true});
canvas.addEventListener("touchend",()=>{dragging=false;lastTouchDist=0;});

// --- Chart: hover (tooltip) ---
canvas.addEventListener("mousemove",handleChartHover);
canvas.addEventListener("mouseleave",()=>{tooltip.style.display="none";writtenTip.style.display="none";});

/* ================================================================
   Buttons
   ================================================================ */
document.getElementById("btnReset").addEventListener("click",()=>resetView());
document.getElementById("btnTheme").addEventListener("click",()=>toggleTheme());

document.querySelectorAll('#burnModeGroup .burn-mode-btn').forEach(btn=>{
    btn.addEventListener('click',e=>{
        e.stopPropagation();
        const newMode = btn.dataset.burnMode;
        if(newMode === BURN_EVENTS[0].mode) return;
        changeBurn(undefined, undefined, newMode);
        // Update UI
        document.querySelectorAll('#burnModeGroup .burn-mode-btn').forEach(b=>
            b.classList.toggle('active', b===btn));
    });
    btn.addEventListener('mousedown',e=>e.stopPropagation());
    btn.addEventListener('touchstart',e=>e.stopPropagation(),{passive:true});
});

// --- Legend toggles ---
document.querySelectorAll('#futureModeGroup .seg').forEach(btn => {
    btn.addEventListener('click', () => {
        if (btn.dataset.mode === futureMode) return; // no change
        futureMode = btn.dataset.mode;
        document.querySelectorAll('#futureModeGroup .seg').forEach(b => b.classList.toggle('active', b === btn));
        requestDraw();
        computeAllScenarios();
    });
});
document.querySelectorAll('.ltoggle').forEach(el=>{
  el.addEventListener('click',()=>handleLegendToggle(el));
});

canvas.style.cursor="crosshair";

/* ================================================================
   Boot
   ================================================================ */
initTheme();
zip234ActivationHeight=3_687_123;
actCollapsed=false;
burnCollapsed=false;
view.tMin=genTime;
view.tMax=blockToTime(6_000_000);
clampView();

  document.querySelectorAll('.ltoggle').forEach(el=>{
  const key=el.dataset.series;
  if(key&&show[key]!==undefined)el.classList.toggle('active',show[key]);
});

function bigPowFP64(base, exp) {
    let result = 1n << 64n, b = base, e = exp;
    while (e > 0) {
        if (e & 1) result = (result * b) >> 64n;
        b = (b * b) >> 64n;
        e >>= 1;
    }
    return result;
}

function getZip234At(h) {
    if (h < zip234ActivationHeight) return null;
    // First try precomputed data
    if (scenarios.zip234.data.length > 0) {
        const z = lookupScenario(scenarios.zip234.data, h);
        if (z && Math.abs(z.h - h) <= SAMPLE_EVERY)
            return { supply: zatToZec(z.supplyZat), issBlock: zatToZec(z.issBlockZat) };
    }
    // Analytical fallback: closed-form exponential decay
    const supAtAct = sumIssuanceRangeClean(0, zip234ActivationHeight);
    const remAtAct = MAX_MONEY_ZAT - supAtAct;
    const ONE_MINUS_K = (1n << 64n) - ZIP234_K_NUM;
    const n = h - zip234ActivationHeight;
    const decayFP = bigPowFP64(ONE_MINUS_K, n);
    const remNow = (remAtAct * decayFP) >> 64n;
    const supNow = MAX_MONEY_ZAT - remNow;
    const issBlockZat = (remNow * ZIP234_K_NUM) >> 64n;
    return { supply: zatToZec(supNow), issBlock: zatToZec(issBlockZat) };
}

requestDraw();computeAllScenarios();
/* ================
   REGRESSION TESTS
   ================ */
setTimeout(function runRegressionTests() {
  const results = [];
  function test(name, fn) {
    try {
      const pass = fn();
      results.push({ name, pass });
    } catch (e) {
      results.push({ name, pass: false, error: e.message });
    }
  }

  // --- HTML / DOM structure ---

  test("actHandle element exists", () => {
    return !!document.getElementById("actHandle");
  });

  test("actBlockInput element exists", () => {
    return !!document.getElementById("actBlockInput");
  });

  test("actDateInput element exists", () => {
    return !!document.getElementById("actDateInput");
  });

  test("actHandle has act-pill child", () => {
    const h = document.getElementById("actHandle");
    return h && !!h.querySelector(".act-pill");
  });

  test("actHandle has act-stem child", () => {
    const h = document.getElementById("actHandle");
    return h && !!h.querySelector(".act-stem");
  });

  test("btnReset exists", () => {
    return !!document.getElementById("btnReset");
  });

  test("btnTheme exists", () => {
    return !!document.getElementById("btnTheme");
  });

  test("writtenTip element exists", () => {
    return !!document.getElementById("writtenTip");
  });

  test("legend has 'supply' toggle", () => {
    return !!document.querySelector('[data-series="supply"]');
  });

  test("legend has 'issDay' toggle", () => {
    return !!document.querySelector('[data-series="issDay"]');
  });

  test("legend has 'annPct' toggle", () => {
    return !!document.querySelector('[data-series="annPct"]');
  });

  // --- Constants and initial state ---

  test("WRITTEN_HEIGHT is defined and > 3,000,000", () => {
    return typeof WRITTEN_HEIGHT === "number" && WRITTEN_HEIGHT > 3_000_000;
  });

  test("BLOSSOM_ACTIVATION_HEIGHT is 653600", () => {
    return BLOSSOM_ACTIVATION_HEIGHT === 653600;
  });

  test("zip234ActivationHeight is >= WRITTEN_HEIGHT at boot", () => {
    return zip234ActivationHeight >= WRITTEN_HEIGHT;
  });

  test("zip234ActivationHeight default is 3,687,123", () => {
    return zip234ActivationHeight === 3_687_123;
  });

  test("MAX_MONEY_ZEC is 21,000,000", () => {
    return MAX_MONEY_ZEC === 21_000_000;
  });

  test("ZIP234_K is defined and positive and < 1", () => {
    return typeof ZIP234_K === "number" && ZIP234_K > 0 && ZIP234_K < 1;
  });

  // --- Toggle state ---

  test("futureMode is 'both' at boot", () => {
    return futureMode === 'both';
  });

  test("showZip234() is true at boot", () => {
    return showZip234() === true;
  });

  test("show.supply is true at boot", () => {
    return show.supply === true;
  });

  test("show.issDay is true at boot", () => {
    return show.issDay === true;
  });

  test("show.annPct is false at boot", () => {
    return show.annPct === false;
  });

  // --- Toggle constraint: can't turn off both default and zip234 ---

  test("futureMode only allows valid values", () => {
    return ['default', 'zip234', 'both'].includes(futureMode);
  });

  // --- Issuance logic ---

  test("issuance_per_block(0) is 0 (slow start)", () => {
    return issuance_per_block(0) === 0n;
  });

  test("issuance_per_block(20000) is 1250000000 (full subsidy pre-Blossom)", () => {
    return issuance_per_block(20000) === 1250000000n;
  });

  test("issuance_per_block(653600) is 625000000 (Blossom halves block subsidy)", () => {
    return issuance_per_block(653600) === 625000000n;
  });

  test("issuance_per_block at halving 1 (1046400) is 312500000", () => {
    return issuance_per_block(1046400) === 312500000n;
  });

  test("issuance_per_block at halving 2 (2726400) is 156250000", () => {
    return issuance_per_block(2726400) === 156250000n;
  });

  test("issuance_per_block just before halving 2 is 312500000", () => {
    return issuance_per_block(2726399) === 312500000n;
  });

  // --- Time anchors ---

  test("Genesis time is Oct 28, 2016", () => {
    return TIME_ANCHORS[0].time === Date.UTC(2016, 9, 28, 7, 56);
  });

  test("blockToTime(0) equals genesis time", () => {
    return blockToTime(0) === TIME_ANCHORS[0].time;
  });

  test("blockToTime is monotonically increasing", () => {
    const h = [0, 100000, 653600, 1046400, 2000000, 2726400, 3000000];
    for (let i = 1; i < h.length; i++) {
      if (blockToTime(h[i]) <= blockToTime(h[i - 1])) return false;
    }
    return true;
  });

  // --- Halving heights ---

  test("halvingHeights returns correct first halving", () => {
    const hh = halvingHeights(2000000);
    return hh.length >= 1 && hh[0] === 1046400;
  });

  test("halvingHeights includes halving 2 at 2726400", () => {
    const hh = halvingHeights(3000000);
    return hh.includes(2726400);
  });

  test("halving spacing is 1,680,000", () => {
    const hh = halvingHeights(6000000);
    for (let i = 1; i < hh.length; i++) {
      if (hh[i] - hh[i - 1] !== 1680000) return false;
    }
    return true;
  });

  // --- ZIP 234 math ---

  test("getZip234At returns null for height below activation", () => {
    return getZip234At(zip234ActivationHeight - 1) === null;
  });

  test("ZIP 234 supply is monotonically increasing", () => {
    const actH = zip234ActivationHeight;
    const heights = [actH, actH + 10000, actH + 100000, actH + 500000];
    let prev = 0;
    for (const h of heights) {
      const z = getZip234At(h);
      if (!z || z.supply <= prev) return false;
      prev = z.supply;
    }
    return true;
  });

  test("ZIP 234 issuance per block is positive and decreasing", () => {
    const actH = zip234ActivationHeight;
    const heights = [actH, actH + 100000, actH + 500000, actH + 1000000];
    let prev = Infinity;
    for (const h of heights) {
      const z = getZip234At(h);
      if (!z || z.issBlock <= 0 || z.issBlock >= prev) return false;
      prev = z.issBlock;
    }
    return true;
  });

  test("ZIP 234 supply never exceeds 21M", () => {
    const z = getZip234At(zip234ActivationHeight + 10_000_000);
    return z !== null && z.supply <= 21_000_000;
  });

  // --- sumIssuanceRangeClean ---

  test("sumIssuanceRangeClean(0,0) is 0", () => {
    return sumIssuanceRangeClean(0, 0) === 0n;
  });

  test("sumIssuanceRangeClean(0,1) equals issuance_per_block(0)", () => {
    return sumIssuanceRangeClean(0, 1) === issuance_per_block(0);
  });

  test("sumIssuanceRangeClean agrees with brute force for small range", () => {
    let brute = 0n;
    for (let h = 20000; h < 20010; h++) brute += issuance_per_block(h);
    return sumIssuanceRangeClean(20000, 20010) === brute;
  });

  // --- View state ---

  test("view.tMin is at or near genesis at boot", () => {
    return Math.abs(view.tMin - genTime) < 86400000; // within 1 day
  });

  test("view.tMax corresponds to roughly block 6M", () => {
    const expected = blockToTime(6_000_000);
    return Math.abs(view.tMax - expected) < 86400000 * 30; // within 30 days
  });

  // --- Activation height minimum constraint ---

  test("Activation height clamp: direct set below WRITTEN_HEIGHT is rejected", () => {
    const saved = zip234ActivationHeight;
    // Simulate what the drag handler should do: set to a low value
    const tooLow = WRITTEN_HEIGHT - 100_000;
    zip234ActivationHeight = tooLow;
    // Now call updateActHandle which is what drag/input paths end with.
    // The constraint should be enforced somewhere in the pipeline.
    // If the code has no clamp, zip234ActivationHeight stays at tooLow â€” that's the bug.
    // We need to check: does any code path actually prevent this?

    // Check if the mousemove handler source contains a clamp against WRITTEN_HEIGHT
    const handlers = [
      // Look at all mousemove listeners â€” we can't easily extract them,
      // but we can inspect the source of known functions
      updateActHandle.toString(),
    ];

    // Restore before we forget
    zip234ActivationHeight = saved;

    // The real test: search the entire script for clamping logic
    const scripts = document.querySelectorAll('script');
    let scriptSource = '';
    for (const s of scripts) {
      if (s.textContent.includes('zip234ActivationHeight')) {
        scriptSource = s.textContent;
        break;
      }
    }

    // There must be code that clamps zip234ActivationHeight to >= WRITTEN_HEIGHT
    // in the drag handler, block input handler, AND date input handler
    const hasDragClamp = scriptSource.includes('WRITTEN_HEIGHT') && 
      (scriptSource.match(/actDragging[\s\S]{0,500}WRITTEN_HEIGHT/) !== null ||
       scriptSource.match(/WRITTEN_HEIGHT[\s\S]{0,500}actDragging/) !== null);

    const hasBlockInputClamp = scriptSource.match(
      /actBlockInput[\s\S]{0,800}WRITTEN_HEIGHT|WRITTEN_HEIGHT[\s\S]{0,800}actBlockInput/
    ) !== null;

    const hasDateInputClamp = scriptSource.match(
      /actDateInput[\s\S]{0,800}WRITTEN_HEIGHT|WRITTEN_HEIGHT[\s\S]{0,800}actDateInput/
    ) !== null;

    if (!hasDragClamp) console.warn("  âš  No WRITTEN_HEIGHT clamp found near drag handler");
    if (!hasBlockInputClamp) console.warn("  âš  No WRITTEN_HEIGHT clamp found near block input handler");
    if (!hasDateInputClamp) console.warn("  âš  No WRITTEN_HEIGHT clamp found near date input handler");

    return hasDragClamp && hasBlockInputClamp && hasDateInputClamp;
  });

  test("Activation height clamp: functional test via block input", () => {
    const saved = zip234ActivationHeight;
    const input = document.getElementById("actBlockInput");
    if (!input) return false;

    // Set input to a value below WRITTEN_HEIGHT and fire Enter
    const tooLow = WRITTEN_HEIGHT - 500_000;
    input.value = String(tooLow);
    input.dispatchEvent(new KeyboardEvent('keydown', { key: 'Enter', bubbles: true }));

    // After the handler runs, activation height should still be >= WRITTEN_HEIGHT
    const pass = zip234ActivationHeight >= WRITTEN_HEIGHT;

    if (!pass) {
      console.warn(`  âš  Block input set activation to ${zip234ActivationHeight}, below WRITTEN_HEIGHT (${WRITTEN_HEIGHT})`);
    }

    // Restore
    zip234ActivationHeight = saved;
    requestDraw();
    return pass;
  });

  test("Activation height clamp: functional test via date input", () => {
    const saved = zip234ActivationHeight;
    const input = document.getElementById("actDateInput");
    if (!input) return false;

    // Use genesis date â€” way before WRITTEN_HEIGHT
    input.value = "Oct 28, 2016";
    input.dispatchEvent(new KeyboardEvent('keydown', { key: 'Enter', bubbles: true }));

    const pass = zip234ActivationHeight >= WRITTEN_HEIGHT;

    if (!pass) {
      console.warn(`  âš  Date input set activation to ${zip234ActivationHeight}, below WRITTEN_HEIGHT (${WRITTEN_HEIGHT})`);
    }

    zip234ActivationHeight = saved;
    requestDraw();
    return pass;
  });

  // --- CSS / styling checks ---

  test("actHandle is above chart (negative or zero top)", () => {
    const h = document.getElementById("actHandle");
    if (!h) return false;
    const top = parseInt(getComputedStyle(h).top) || parseInt(h.style.top) || -20;
    return top <= 0;
  });

  test("Activation stem bottom aligns in collapsed and expanded states", () => {
    // This test needs the DOM to be fully laid out.
    // Schedule it to run after next frame and report async.
    // For now, force a synchronous draw + layout:

    // Ensure enough data exists to draw
    const testData = scenarios.default.data.length >= 2 ? scenarios.default.data : scenarios.zip234.data;
    if (testData.length < 2) return false;

    // Force a synchronous draw (populates layout, sizes canvas, calls updateActHandle)
    drawRAF = null; // clear any pending RAF
    draw();

    if (!layout || !layout.MG || !layout.PW) {
      console.warn("  âš  Stem test: layout not populated after draw()");
      return false;
    }

    const stem = document.querySelector("#actHandle .act-stem");
    const wrapEl = document.getElementById("chartWrap");
    if (!stem || !wrapEl) return false;

    // Verify the handle is actually visible
    if (actHandle.style.display === "none") {
      console.warn("  âš  Stem test: actHandle is hidden (activation out of view?)");
      return false;
    }

    const saved = actCollapsed;
    const eps = 2.0;

    // Measure in expanded mode
    actCollapsed = false;
    updateActHandle();
    actHandle.offsetHeight;
    const wrapRect1 = wrapEl.getBoundingClientRect();
    const stemRect1 = stem.getBoundingClientRect();
    const stemBottom1 = stemRect1.bottom - wrapRect1.top;

    // Measure in collapsed mode
    actCollapsed = true;
    updateActHandle();
    actHandle.offsetHeight;
    const wrapRect2 = wrapEl.getBoundingClientRect();
    const stemRect2 = stem.getBoundingClientRect();
    const stemBottom2 = stemRect2.bottom - wrapRect2.top;

    // Restore
    actCollapsed = saved;
    updateActHandle();

    const diff = Math.abs(stemBottom1 - stemBottom2);
    const pass = diff <= eps && stemRect1.height > 0 && stemRect2.height > 0;

    if (!pass) {
      console.warn(`  âš  Stem bottom expanded=${stemBottom1.toFixed(1)}px, collapsed=${stemBottom2.toFixed(1)}px, diff=${diff.toFixed(1)}px, heights=${stemRect1.height.toFixed(1)}/${stemRect2.height.toFixed(1)}`);
    }

    return pass;
  });

  // --- Report ---

  const passed = results.filter(r => r.pass).length;
  const failed = results.filter(r => !r.pass).length;
  const total = results.length;

  console.log(`%c=== REGRESSION TESTS: ${passed}/${total} passed, ${failed} failed ===`,
    failed > 0 ? "color:red;font-weight:bold;font-size:14px" : "color:green;font-weight:bold;font-size:14px");

  for (const r of results) {
    if (r.pass) {
      console.log(`  %câœ“ ${r.name}`, "color:green");
    } else {
      console.log(`  %câœ— ${r.name}${r.error ? " â€” " + r.error : ""}`, "color:red;font-weight:bold");
    }
  }

  if (failed > 0) {
    console.warn(`âš ï¸ ${failed} regression test(s) FAILED â€” check for regressions before shipping!`);
  }
}, 500);
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Zcash Supply & Issuance</title>
<style>
  :root{
    --bg:#0f172a; --fg:#e2e8f0; --muted:#94a3b8; --panel:#0b1224;
    --supplyObs:#f59e0b; --issObs:#22d3ee;
    --supplyExp:rgba(245,158,11,0.55); --issExp:rgba(34,211,238,0.55);
    --annualObs:#4ade80; --annualExp:rgba(74,222,128,0.55);
    --eventObs:rgba(96,165,250,0.45); --eventHalv:rgba(239,68,68,0.35);
    --written:rgba(167,139,250,0.65);
    --zip234Supply:#ec4899; --zip234Iss:#a78bfa; --zip234Ann:#fb7185;
    --zip234Act:rgba(236,72,153,0.50);
    --burnEvent:rgba(255,80,80,0.70);
    --controlsBg:rgba(2,6,23,0.25); --controlsBorder:rgba(148,163,184,0.15);
    --btnBg:rgba(2,6,23,0.25); --btnBorder:rgba(148,163,184,0.22);
    --btnHover:rgba(148,163,184,0.4);
    --tooltipBg:rgba(15,23,42,0.98); --tooltipBorder:rgba(148,163,184,0.25);
    --gridLine:rgba(148,163,184,0.08); --capLine:rgba(245,158,11,0.20);
    --frameBorder:rgba(148,163,184,0.10);
    --handleBg:rgba(236,72,153,0.92); --handleBorder:#fff;
    --toggleActiveBg:rgba(148,163,184,0.08); --toggleHoverBg:rgba(148,163,184,0.12);
  }
  [data-theme="light"]{
    --bg:#f8fafc; --fg:#1e293b; --muted:#64748b; --panel:#ffffff;
    --supplyObs:#d97706; --issObs:#0891b2;
    --supplyExp:rgba(217,119,6,0.55); --issExp:rgba(8,145,178,0.55);
    --annualObs:#16a34a; --annualExp:rgba(22,163,74,0.55);
    --eventObs:rgba(59,130,246,0.35); --eventHalv:rgba(220,38,38,0.30);
    --written:rgba(124,58,237,0.55);
    --zip234Supply:#db2777; --zip234Iss:#7c3aed; --zip234Ann:#e11d48;
    --zip234Act:rgba(219,39,119,0.40);
    --burnEvent:rgba(220,38,38,0.60);
    --controlsBg:rgba(241,245,249,0.85); --controlsBorder:rgba(148,163,184,0.25);
    --btnBg:rgba(255,255,255,0.8); --btnBorder:rgba(148,163,184,0.35);
    --btnHover:rgba(148,163,184,0.55);
    --tooltipBg:rgba(255,255,255,0.98); --tooltipBorder:rgba(148,163,184,0.35);
    --gridLine:rgba(148,163,184,0.12); --capLine:rgba(217,119,6,0.25);
    --frameBorder:rgba(148,163,184,0.18);
    --handleBg:rgba(219,39,119,0.92); --handleBorder:#1e293b;
    --toggleActiveBg:rgba(148,163,184,0.12); --toggleHoverBg:rgba(148,163,184,0.18);
  }
  *{margin:0;padding:0;box-sizing:border-box}
  body{background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,sans-serif;
    display:flex;flex-direction:column;align-items:center;padding:22px;gap:10px}
  h1{font-size:1.35rem;color:var(--supplyObs);margin-bottom:2px}
  .sub{font-size:.82rem;color:var(--muted);text-align:center;max-width:760px;line-height:1.45}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center;justify-content:center;
    background:var(--controlsBg);border:1px solid var(--controlsBorder);border-radius:10px;padding:10px 18px}
  .controls button{font:600 .78rem/1 system-ui;color:var(--fg);background:var(--btnBg);
    border:1px solid var(--btnBorder);border-radius:6px;padding:7px 14px;cursor:pointer;transition:background .12s}
  .controls button:hover{background:var(--btnHover)}
  .chart-wrap{position:relative;display:inline-block}
  canvas{border-radius:8px;background:var(--panel);display:block}
  .legend{display:flex;flex-wrap:wrap;gap:10px 20px;font-size:.78rem;align-items:center;justify-content:center;color:var(--muted)}
  .legend span{display:flex;align-items:center;gap:5px}
  .sw{width:10px;height:10px;border-radius:50%;display:inline-block;flex-shrink:0}
  .dash{width:18px;height:0;border-top:2px dashed var(--muted);display:inline-block}
  .ltoggle{cursor:pointer;user-select:none;padding:4px 10px;border-radius:999px;
    border:1.5px solid transparent;transition:opacity .15s,border-color .15s,background .15s}
  .ltoggle.active{border-color:var(--btnBorder);background:var(--toggleActiveBg);opacity:1}
  .ltoggle:not(.active){opacity:.38}
  .ltoggle:not(.active) .sw{background:var(--muted)!important}
  .ltoggle:hover{opacity:.85;background:var(--toggleHoverBg)}
  /* Draggable activation handle â€” ABOVE the chart with gap */
  #actHandle{position:absolute;display:none;z-index:20;cursor:ew-resize;
    transform:translateX(-50%);pointer-events:auto;top:-20px}
  #actHandle .act-pill{background:var(--handleBg);color:#fff;font:600 .68rem/1 system-ui;
    padding:5px 8px;border-radius:6px;border:1.5px solid var(--handleBorder);
    white-space:nowrap;display:flex;flex-direction:column;align-items:center;gap:2px;
    box-shadow:0 2px 8px rgba(0,0,0,.3);user-select:none}
  #actHandle .act-pill .act-row{display:flex;align-items:center;gap:4px}
  #actHandle .act-pill input{width:72px;padding:2px 4px;border-radius:3px;border:1px solid rgba(255,255,255,.3);
    background:rgba(0,0,0,.25);color:#fff;font:600 .66rem/1 system-ui;text-align:center}
  #actHandle .act-pill input.act-date{width:88px}
  #actHandle .act-stem{width:2px;background:var(--handleBg);margin:0 auto}
  [data-theme="light"] #actHandle .act-pill input{background:rgba(255,255,255,.5);color:#1e293b;border-color:rgba(0,0,0,.2)}
  /* Written tooltip */
  #writtenTip{position:fixed;display:none;z-index:15;pointer-events:none;
    background:var(--tooltipBg);color:var(--fg);border:1px solid var(--tooltipBorder);
    border-radius:6px;padding:8px 12px;font-size:.72rem;line-height:1.4;
    backdrop-filter:blur(6px);-webkit-backdrop-filter:blur(6px);white-space:nowrap;
    transform:translateX(-50%)}
  #tooltip{position:fixed;display:none;border-radius:8px;padding:10px 14px;font-size:.76rem;
    pointer-events:none;z-index:10;line-height:1.55;max-width:400px;
    background:var(--tooltipBg);color:var(--fg);border:1px solid var(--tooltipBorder);
    backdrop-filter:blur(6px);-webkit-backdrop-filter:blur(6px)}
  #tooltip .tt-muted{color:var(--muted)} #tooltip .tt-obs{color:#38bdf8;font-weight:600}
  #tooltip .tt-exp{color:var(--written);font-weight:600}
  @media(max-width:600px){body{padding:10px;gap:8px}h1{font-size:1.1rem}.sub{font-size:.72rem}
    .controls{padding:8px 10px;gap:6px}.controls button{padding:8px 10px;font-size:.72rem;min-height:36px}
    .legend{font-size:.7rem;gap:6px 12px}.ltoggle{padding:6px 12px;min-height:36px}}
</style>
</head>
<body>
<h1>Zcash Supply &amp; Issuance</h1>
<p class="sub">
  Zcash consensus issuance logic with optional <b>ZIP 234</b> smooth-issuance overlay.<br>
  <b>Scroll</b> to pan, <b>Ctrl/âŒ˜+scroll</b> (or pinch) to zoom, <b>drag</b> to pan, <b>double-click</b> to reset.
</p>
<div class="chart-wrap" id="chartWrap">
  <canvas id="chart"></canvas>
  <div id="actHandle">
    <div class="act-pill">
      <div class="act-row">ZIP 234 at <input id="actBlockInput" type="text" value="3687123"></div>
      <div class="act-row"><input id="actDateInput" type="text" class="act-date" value=""></div>
    </div>
    <div class="act-stem"></div>
  </div>
  <div id="writtenTip"></div>
</div>
<div class="legend" id="legend">
  <span class="ltoggle active" data-series="default"><span class="sw" style="background:var(--supplyObs)"></span>Default</span>
  <span class="ltoggle active" data-series="zip234"><span class="sw" style="background:var(--zip234Supply)"></span>ZIP 234</span>
  <span style="color:var(--muted)">â”‚</span>
  <span class="ltoggle active" data-series="supply"><span class="sw" style="background:var(--supplyObs)"></span>Supply</span>
  <span class="ltoggle active" data-series="issDay"><span class="sw" style="background:var(--issObs)"></span>Issuance / Day</span>
  <span class="ltoggle" data-series="annPct"><span class="sw" style="background:var(--annualObs)"></span>Annual %</span>
  <span><span class="dash"></span> Dashed = <b>Expected</b></span>
</div>
<div id="tooltip"></div>
<div class="controls">
  <button id="btnReset">Reset view</button>
  <button id="btnTheme">â˜€/ðŸŒ™</button>
</div>
<script>
/* ================================================================
   Toggle state
   ================================================================ */
const show={supply:true,issDay:true,annPct:false,default:true,zip234:true};

/* ================================================================
   Theme
   ================================================================ */
function getTheme(){return document.documentElement.getAttribute("data-theme")||"dark";}
function setTheme(t){if(t==="light")document.documentElement.setAttribute("data-theme","light");
  else document.documentElement.removeAttribute("data-theme");try{localStorage.setItem("zec-theme",t)}catch(e){}}
function toggleTheme(){setTheme(getTheme()==="dark"?"light":"dark");requestDraw();}
function initTheme(){try{const s=localStorage.getItem("zec-theme");if(s){setTheme(s);return;}}catch(e){}
  if(window.matchMedia&&window.matchMedia("(prefers-color-scheme:light)").matches)setTheme("light");}
function cv(name){return getComputedStyle(document.documentElement).getPropertyValue(name).trim();}

/* ================================================================
   Time anchors
   ================================================================ */
const TIME_ANCHORS=[
  {h:0,time:Date.UTC(2016,9,28,7,56),label:"Genesis"},
  {h:653_600,time:Date.UTC(2019,11,11,21,50),label:"Blossom"},
  {h:1_046_400,time:Date.UTC(2020,10,18,12,34),label:"Halving 1"},
  {h:2_726_400,time:Date.UTC(2024,10,23,1,51),label:"Halving 2"},
];

const BLOSSOM_ACTIVATION_HEIGHT=653_600;
const WRITTEN_HEIGHT=3_234_946;
const BURN_EVENTS=[
  {h:5_000_000, zec:2_000_000, label:"Burn 2M â“©"}
];
function totalBurnedAtHeight(h){let total=0;for(const b of BURN_EVENTS)if(h>=b.h)total+=b.zec;return total;}
const ONE_YEAR_MS=365.25*86400*1000;

const SEGMENTS=[];
for(let i=0;i<TIME_ANCHORS.length-1;i++){
  const a=TIME_ANCHORS[i],b=TIME_ANCHORS[i+1];
  SEGMENTS.push({startH:a.h,endH:b.h,startTime:a.time,
    secPerBlock:(b.time-a.time)/1000/(b.h-a.h)});
}

function segmentForHeight(h){for(let i=0;i<SEGMENTS.length;i++)if(h<=SEGMENTS[i].endH)return SEGMENTS[i];return SEGMENTS[SEGMENTS.length-1];}
function blockToTime(h){const s=segmentForHeight(h);return s.startTime+(h-s.startH)*s.secPerBlock*1000;}
function secsPerBlock(h){return segmentForHeight(h).secPerBlock;}
function timeToHeight(t){for(let i=SEGMENTS.length-1;i>=0;i--){const s=SEGMENTS[i];if(t>=s.startTime)return s.startH+(t-s.startTime)/1000/s.secPerBlock;}const s=SEGMENTS[0];return s.startH+(t-s.startTime)/1000/s.secPerBlock;}
function heightAfterDuration(h,durationMs){
  let remaining=durationMs/1000,cur=h;
  for(let i=0;i<SEGMENTS.length;i++){const s=SEGMENTS[i];if(cur>s.endH)continue;
    const hStart=Math.max(cur,s.startH),secsToEnd=(s.endH-hStart)*s.secPerBlock;
    if(remaining<=secsToEnd)return hStart+remaining/s.secPerBlock;remaining-=secsToEnd;cur=s.endH;}
  const last=SEGMENTS[SEGMENTS.length-1];return Math.max(cur,last.endH)+remaining/last.secPerBlock;
}

const genTime=blockToTime(0);
const writtenTime=blockToTime(WRITTEN_HEIGHT);
function fmtDate(ms){const d=new Date(ms);const mo=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];return mo[d.getUTCMonth()]+" "+d.getUTCDate()+", "+d.getUTCFullYear();}

/* ================================================================
   Halving heights generator
   ================================================================ */
function halvingHeights(maxH){const r=[];let h=1_046_400;while(h<=maxH){r.push(h);h+=1_680_000;}return r;}

/* ================================================================
   issuance_per_block() â€” zcash consensus
   ================================================================ */
function issuance_per_block(blockheight){
  const MAX_BLOCK_SUBSIDY=1250000000n,SLOW_START_INTERVAL=20000,SLOW_START_SHIFT=10000,
    SLOW_START_RATE=62500n,BLOSSOM_ACT=653600,BLOSSOM_RATIO=2n,
    PRE_HALVING=840000,POST_HALVING=1680000n;
  const h=BigInt(blockheight);
  if(blockheight<SLOW_START_SHIFT)return SLOW_START_RATE*h;
  if(blockheight<SLOW_START_INTERVAL)return SLOW_START_RATE*(h+1n);
  let halvings;
  if(blockheight>=BLOSSOM_ACT){const sc=BigInt(BLOSSOM_ACT-SLOW_START_SHIFT)*BLOSSOM_RATIO+(h-BigInt(BLOSSOM_ACT));halvings=Number(sc/POST_HALVING);}
  else halvings=Math.floor((blockheight-SLOW_START_SHIFT)/PRE_HALVING);
  if(halvings>=64)return 0n;
  if(blockheight>=BLOSSOM_ACT)return(MAX_BLOCK_SUBSIDY/BLOSSOM_RATIO)>>BigInt(halvings);
  return MAX_BLOCK_SUBSIDY>>BigInt(halvings);
}

/* ================================================================
   Fast piecewise summation
   ================================================================ */
const G_MAX_SUB=1250000000n,G_SLOW_INT=20000,G_SLOW_SHIFT=10000,
  G_SLOW_RATE=62500n,G_BLOSSOM_H=653600,G_RATIO=2n,G_POST_HALV=1680000,G_HALV_OFF=633600;

function sumArith(a,b){if(b<a)return 0n;const A=BigInt(a),B=BigInt(b),n=B-A+1n;return(A+B)*n/2n;}
function halvIdxPost(h){return Math.floor((h+G_HALV_OFF)/G_POST_HALV);}
function nextHalvPost(h){return(halvIdxPost(h)+1)*G_POST_HALV-G_HALV_OFF;}

function sumIssuanceRangeClean(startInc,endExc){
  if(endExc<=startInc)return 0n;let h=startInc,total=0n;
  while(h<endExc){
    if(h<G_SLOW_SHIFT){const e=Math.min(endExc,G_SLOW_SHIFT);total+=G_SLOW_RATE*sumArith(h,e-1);h=e;continue;}
    if(h<G_SLOW_INT){const e=Math.min(endExc,G_SLOW_INT);total+=G_SLOW_RATE*sumArith(h+1,e);h=e;continue;}
    if(h<G_BLOSSOM_H){const e=Math.min(endExc,G_BLOSSOM_H);total+=G_MAX_SUB*BigInt(e-h);h=e;continue;}
    const k=halvIdxPost(h);if(k>=64)break;
    const nxt=nextHalvPost(h),e=Math.min(endExc,nxt);
    total+=(G_MAX_SUB/G_RATIO>>BigInt(k))*BigInt(e-h);h=e;
  }return total;
}

/* ================================================================
   Default data & progressive computation
   ================================================================ */
const ZATOSHI=100_000_000,SAMPLE_EVERY=1000;
const data=[];let computedUpTo=-1,cumulativeBig=0n,targetHeightWanted=0,computing=false;

function pushPoint(h,cumBig){
  const iss=issuance_per_block(h),issBlock=Number(iss)/ZATOSHI,spb=secsPerBlock(h),
    time=blockToTime(h),supply=Number(cumBig)/ZATOSHI-totalBurnedAtHeight(h),issDay=issBlock*(86400/spb);
  let annualPct=NaN,annualPctIsExpected=false;
  if(supply>0&&h>=20000){
    const h1yr=Math.floor(heightAfterDuration(h,ONE_YEAR_MS));
    const annIss=Number(sumIssuanceRangeClean(h,h1yr))/ZATOSHI;
    annualPct=(annIss/supply)*100;annualPctIsExpected=(h1yr>WRITTEN_HEIGHT);
  }
  data.push({h,time,supply,issBlock,issDay,annualPct,annualPctIsExpected});
}

function advanceTo(targetH){
  let h=computedUpTo+1;while(h<=targetH){cumulativeBig+=issuance_per_block(h);
    if(h%SAMPLE_EVERY===0)pushPoint(h,cumulativeBig);h++;}computedUpTo=targetH;
}

async function computeAsync(targetH){
  if(computing)return;computing=true;const BATCH=80_000;
  while(computedUpTo<targetH){advanceTo(Math.min(computedUpTo+BATCH,targetH));requestDraw();await new Promise(r=>setTimeout(r,0));}
  computing=false;requestDraw();
}

/* ================================================================
   ZIP 234 â€” smooth issuance
   ================================================================ */
const MAX_MONEY_ZEC=21_000_000;
const ZIP234_K=1-Math.pow(2,-1/1680000);
let zip234ActivationHeight=3_687_123;
let zip234Data=[];
let zip234RemainingAtAct=0;
let zip234CachedActH=-1;
let zip234MaxH=-1;

function ensureZip234Cache(){
  if(zip234CachedActH!==zip234ActivationHeight){
    const supZat=sumIssuanceRangeClean(0,zip234ActivationHeight);
    zip234RemainingAtAct = MAX_MONEY_ZEC - (Number(supZat)/ZATOSHI - totalBurnedAtHeight(zip234ActivationHeight));
    zip234CachedActH=zip234ActivationHeight;
    zip234Data=[];zip234MaxH=-1;
  }
}

function computeZip234(maxH){
  ensureZip234Cache();
  if(maxH<=zip234MaxH)return;
  zip234Data=[];
  const actH=zip234ActivationHeight,R0=zip234RemainingAtAct;
  pushZ234(actH,R0,actH);
  let next=Math.ceil(actH/SAMPLE_EVERY)*SAMPLE_EVERY;
  if(next===actH)next+=SAMPLE_EVERY;
  for(let h=next;h<=maxH;h+=SAMPLE_EVERY)pushZ234(h,R0,actH);
  zip234MaxH=maxH;
}

function getZip234At(h){
  if(h<zip234ActivationHeight)return null;
  ensureZip234Cache();
  const actH=zip234ActivationHeight;
  // Walk through burn events that fall between activation and h
  // Between burns, closed-form exponential is valid
  let segStart=actH;
  let R=zip234RemainingAtAct; // remaining at start of current segment
  // Add back burns that happened before activation (shouldn't happen, but safe)
  // Process burns in order
  const relevantBurns=BURN_EVENTS.filter(b=>b.h>=actH&&b.h<=h).sort((a,b)=>a.h-b.h);
  for(const b of relevantBurns){
    // Decay from segStart to burn height
    const elapsed=b.h-segStart;
    R=R*Math.pow(1-ZIP234_K,elapsed);
    // Burn increases remaining (supply decreases, so 21M-supply increases)
    R+=b.zec;
    segStart=b.h;
  }
  // Decay from last segment start to h
  const elapsed=h-segStart;
  const decayBefore=Math.pow(1-ZIP234_K,elapsed);
  const decayAfter=Math.pow(1-ZIP234_K,elapsed+1);
  const remainBefore=R*decayBefore;
  const remainAfter=R*decayAfter;
  const supply=MAX_MONEY_ZEC-remainAfter;
  const issBlock=ZIP234_K*remainBefore;
  const spb=secsPerBlock(h);
  const issDay=issBlock*(86400/spb);
  const bpy=ONE_YEAR_MS/1000/spb;
  // For annual %, we need to account for any burns in the coming year too
  // Approximate: just use current remaining for simplicity
  const yearIss=remainAfter*(1-Math.pow(1-ZIP234_K,bpy));
  const annualPct=supply>0 ? (yearIss/supply)*100 : NaN;
  return { supply, issBlock, issDay, annualPct };
}

function pushZ234(h,R0,actH){
  const z=getZip234At(h);
  if(!z)return;
  zip234Data.push({ h, time:blockToTime(h), supply:z.supply, issBlock:z.issBlock, issDay:z.issDay, annualPct:z.annualPct });
}

/* ================================================================
   View state
   ================================================================ */
const MAX_TIME=Date.UTC(2100,0,1),MIN_SPAN=30*86400_000;
const view={tMin: genTime,tMax: blockToTime(6_000_000)};

function clampView(){
  let span=view.tMax-view.tMin;
  if(span<MIN_SPAN){const mid=(view.tMin+view.tMax)/2;view.tMin=mid-MIN_SPAN/2;view.tMax=mid+MIN_SPAN/2;span=MIN_SPAN;}
  if(view.tMin<genTime-2*ONE_YEAR_MS){view.tMax+=(genTime-2*ONE_YEAR_MS-view.tMin);view.tMin=genTime-2*ONE_YEAR_MS;}
  if(view.tMax>MAX_TIME){view.tMin-=(view.tMax-MAX_TIME);view.tMax=MAX_TIME;}
  if(view.tMin<genTime-2*ONE_YEAR_MS)view.tMin=genTime-2*ONE_YEAR_MS;
}

function resetView(){view.tMin=genTime;view.tMax=blockToTime(6_000_000);clampView();requestDraw();requestComputeForView();}

function zoomToActivation(h){
  view.tMin=genTime;
  const endH=Math.max(h*2,h+100_000);
  view.tMax=blockToTime(endH);
  clampView();requestDraw();requestComputeForView();
}

function requestComputeForView(){
  const needed=Math.max(0,Math.ceil(timeToHeight(view.tMax+ONE_YEAR_MS))+10_000);
  if(needed>targetHeightWanted)targetHeightWanted=needed;
  if(targetHeightWanted>computedUpTo)computeAsync(targetHeightWanted);
}

/* ================================================================
   Right margin layout
   ================================================================ */
function computeRightMargin(isNarrow){
  if(isNarrow){if(show.supply)return 52;return 16;}
  return show.supply?70:20;
}

function rightAxisLayout(isNarrow){
  const r={supply:null};
  if(!show.supply)return r;
  if(isNarrow){r.supply={tickX:6,titleX:null};return r;}
  r.supply={tickX:6,titleX:50};
  return r;
}

function computeLeftMargin(isNarrow){
  if(isNarrow){if(show.issDay||show.annPct)return 52;return 16;}
  const AXIS_W=62;let count=0;if(show.issDay)count++;if(show.annPct)count++;
  return count===0?20:8+count*AXIS_W;
}

function leftAxisLayout(isNarrow){
  const r={issDay:null,annPct:null};
  if(isNarrow){if(show.issDay)r.issDay={tickX:6,titleX:null};else if(show.annPct)r.annPct={tickX:6,titleX:null};return r;}
  let off=6;
  if(show.issDay){r.issDay={tickX:off,titleX:off+44};off+=62;}
  if(show.annPct){r.annPct={tickX:off,titleX:off+44};off+=62;}
  return r;
}

/* ================================================================
   Drawing
   ================================================================ */
let drawRAF=null;const layout={};

function requestDraw(){if(!drawRAF)drawRAF=requestAnimationFrame(()=>{drawRAF=null;draw();});}

function draw(){
  if(data.length<2)return;

  // Compute ZIP 234 data if needed
  if(show.zip234){
    const mh=Math.max(
      Math.ceil(timeToHeight(view.tMax+ONE_YEAR_MS))+10_000,
      zip234ActivationHeight+100_000
    );
    computeZip234(mh);
  }

  const canvas=document.getElementById("chart");
  const dpr=window.devicePixelRatio||1;
  const isNarrow=window.innerWidth<600;
  const CSS_W=Math.min(960,window.innerWidth-20);
  const CSS_H=isNarrow?Math.round(CSS_W*0.62):Math.round(CSS_W*0.54);
  canvas.width=CSS_W*dpr;canvas.height=CSS_H*dpr;
  canvas.style.width=CSS_W+"px";canvas.style.height=CSS_H+"px";
  const ctx=canvas.getContext("2d");ctx.scale(dpr,dpr);

  const rightMar=computeRightMargin(isNarrow);
  const leftMar=computeLeftMargin(isNarrow);
  const MG={top:28,right:rightMar,bottom:52,left:leftMar};
  const PW=CSS_W-MG.left-MG.right,PH=CSS_H-MG.top-MG.bottom;
  Object.assign(layout,{CSS_W,CSS_H,MG,PW,PH});

  const axR=rightAxisLayout(isNarrow);
  const axL=leftAxisLayout(isNarrow);

  const T={bg:cv("--bg"),fg:cv("--fg"),muted:cv("--muted"),panel:cv("--panel"),
    supplyObs:cv("--supplyObs"),issObs:cv("--issObs"),supplyExp:cv("--supplyExp"),issExp:cv("--issExp"),
    annualObs:cv("--annualObs"),annualExp:cv("--annualExp"),
    eventObs:cv("--eventObs"),eventHalv:cv("--eventHalv"),written:cv("--written"),
    gridLine:cv("--gridLine"),capLine:cv("--capLine"),frameBorder:cv("--frameBorder"),
    zip234Supply:cv("--zip234Supply"),zip234Iss:cv("--zip234Iss"),zip234Ann:cv("--zip234Ann"),
    zip234Act:cv("--zip234Act"),
    burnEvent:cv("--burnEvent"),
    supplyFillObs:getTheme()==="dark"?"rgba(245,158,11,0.14)":"rgba(217,119,6,0.10)",
    supplyFillExp:getTheme()==="dark"?"rgba(245,158,11,0.06)":"rgba(217,119,6,0.05)",
    zip234FillObs:getTheme()==="dark"?"rgba(236,72,153,0.12)":"rgba(219,39,119,0.08)",
    zip234FillExp:getTheme()==="dark"?"rgba(236,72,153,0.06)":"rgba(219,39,119,0.04)"
  };

  ctx.fillStyle=T.panel;ctx.fillRect(0,0,CSS_W,CSS_H);

  const ySupMax=22_000_000,yIssDayMax=8_000,yAnnMax=30;
  const xP=t=>MG.left+((t-view.tMin)/(view.tMax-view.tMin))*PW;
  const ySP=s=>MG.top+PH-(s/ySupMax)*PH;
  const yIP=v=>MG.top+PH-(v/yIssDayMax)*PH;
  const yAP=p=>MG.top+PH-(p/yAnnMax)*PH;

  // Determine how much default data to show
  const defaultCutoffH=show.default?Infinity:(show.zip234?zip234ActivationHeight:-1);
  const D=data.filter(d=>d.time>=view.tMin&&d.time<=view.tMax&&d.h<=defaultCutoffH);

  // Grid
  if(show.supply){
    ctx.strokeStyle=T.gridLine;ctx.lineWidth=1;
    for(let s=0;s<=ySupMax;s+=3_000_000){ctx.beginPath();ctx.moveTo(MG.left,ySP(s));ctx.lineTo(MG.left+PW,ySP(s));ctx.stroke();}
  }

  // 21M cap
  if(show.supply){
    ctx.save();ctx.setLineDash([6,4]);ctx.strokeStyle=T.capLine;ctx.lineWidth=1;
    ctx.beginPath();ctx.moveTo(MG.left,ySP(21e6));ctx.lineTo(MG.left+PW,ySP(21e6));ctx.stroke();ctx.setLineDash([]);
    ctx.fillStyle=T.capLine;ctx.font="10px system-ui";ctx.textAlign="left";ctx.fillText("21 M cap",MG.left+4,ySP(21e6)-4);ctx.restore();
  }

  // Event verticals
  ctx.save();ctx.setLineDash([4,4]);ctx.lineWidth=1;

  // Blossom
  {const t=blockToTime(BLOSSOM_ACTIVATION_HEIGHT);
    if(t>=view.tMin&&t<=view.tMax){ctx.strokeStyle=T.eventObs;ctx.beginPath();ctx.moveTo(xP(t),MG.top);ctx.lineTo(xP(t),MG.top+PH);ctx.stroke();}}

  // Halvings (only up to defaultCutoffH)
  {const halvMax=defaultCutoffH===Infinity?Math.ceil(timeToHeight(view.tMax))+200_000:defaultCutoffH;
    for(const hh of halvingHeights(halvMax)){
      const t=blockToTime(hh);if(t>=view.tMin&&t<=view.tMax){ctx.strokeStyle=T.eventHalv;ctx.beginPath();ctx.moveTo(xP(t),MG.top);ctx.lineTo(xP(t),MG.top+PH);ctx.stroke();}}}

  // Written ("Sim written")
  {const t=writtenTime;if(t>=view.tMin&&t<=view.tMax){ctx.strokeStyle=T.written;ctx.lineWidth=1.5;ctx.beginPath();ctx.moveTo(xP(t),MG.top);ctx.lineTo(xP(t),MG.top+PH);ctx.stroke();}}

  // Burn events
  for(const b of BURN_EVENTS){const t=blockToTime(b.h);if(t>=view.tMin&&t<=view.tMax){ctx.strokeStyle=T.burnEvent;ctx.lineWidth=1.5;ctx.setLineDash([4,4]);ctx.beginPath();ctx.moveTo(xP(t),MG.top);ctx.lineTo(xP(t),MG.top+PH);ctx.stroke();}}

  // ZIP 234 activation
  if(show.zip234){
    const t=blockToTime(zip234ActivationHeight);
    if(t>=view.tMin&&t<=view.tMax){ctx.strokeStyle=T.zip234Act;ctx.lineWidth=1.5;ctx.setLineDash([6,3]);
      ctx.beginPath();ctx.moveTo(xP(t),MG.top);ctx.lineTo(xP(t),MG.top+PH);ctx.stroke();}
  }

  ctx.setLineDash([]);ctx.restore();

  // Clip to plot area
  ctx.save();ctx.beginPath();ctx.rect(MG.left,MG.top,PW,PH);ctx.clip();

  // Helper: draw split line (observed solid / expected dashed)
  function drawSplit(pts,splitH,yFn,obsC,expC,lw){
    ctx.beginPath();ctx.strokeStyle=obsC;ctx.lineWidth=lw;ctx.setLineDash([]);
    let started=false;
    for(const p of pts){if(p.h>splitH)break;const py=yFn(p);if(!isFinite(py))continue;
      const px=xP(p.time);if(!started){ctx.moveTo(px,py);started=true;}else ctx.lineTo(px,py);}
    ctx.stroke();
    ctx.beginPath();ctx.strokeStyle=expC;ctx.lineWidth=lw;ctx.setLineDash([6,4]);started=false;
    for(const p of pts){if(p.h<splitH){const py=yFn(p);if(!isFinite(py))continue;ctx.moveTo(xP(p.time),py);started=true;continue;}
      const py=yFn(p);if(!isFinite(py))continue;const px=xP(p.time);
      if(!started){ctx.moveTo(px,py);started=true;}else ctx.lineTo(px,py);}
    ctx.stroke();ctx.setLineDash([]);
  }
  // Helper: fill under supply curve
  function fillAreaAlways(pts,yFn,color){
    if(pts.length<2)return;
    ctx.beginPath();
    ctx.moveTo(xP(pts[0].time),ySP(0));
    for(const p of pts){const py=yFn(p);if(isFinite(py))ctx.lineTo(xP(p.time),py);}
    ctx.lineTo(xP(pts[pts.length-1].time),ySP(0));
    ctx.closePath();ctx.fillStyle=color;ctx.fill();
  }

  const ANNUAL_PCT_SPLIT_HEIGHT=WRITTEN_HEIGHT;

  // Default model curves
  if(D.length>=2){
    if(show.supply){
      fillAreaAlways(D,p=>ySP(p.supply),T.supplyFillObs);
      drawSplit(D,WRITTEN_HEIGHT,p=>ySP(p.supply),T.supplyObs,T.supplyExp,2);
    }
    if(show.issDay)drawSplit(D,WRITTEN_HEIGHT,p=>yIP(p.issDay),T.issObs,T.issExp,2);
    if(show.annPct)drawSplit(D,ANNUAL_PCT_SPLIT_HEIGHT,p=>{const v=p.annualPct;if(!isFinite(v)||v>200)return NaN;return yAP(v);},T.annualObs,T.annualExp,1.8);
  }

  // ZIP 234 curves
  if(show.zip234&&zip234Data.length>=1){
    const Z=zip234Data.filter(d=>d.time>=view.tMin&&d.time<=view.tMax);
    if(show.supply&&Z.length>=2){
      fillAreaAlways(Z,p=>ySP(p.supply),T.zip234FillObs);
    }

    function drawZ234Line(yFn,color,lw){
      if(Z.length<1)return;ctx.beginPath();ctx.setLineDash([6,4]);ctx.strokeStyle=color;ctx.lineWidth=lw;
      let started=false;for(const p of Z){const py=yFn(p);if(!isFinite(py))continue;
        const px=xP(p.time);if(!started){ctx.moveTo(px,py);started=true;}else ctx.lineTo(px,py);}
      ctx.stroke();ctx.setLineDash([]);
    }

    if(show.supply)drawZ234Line(p=>ySP(p.supply),T.zip234Supply,2.5);
    if(show.issDay)drawZ234Line(p=>yIP(p.issDay),T.zip234Iss,2.5);
    if(show.annPct)drawZ234Line(p=>{const v=p.annualPct;if(!isFinite(v)||v>200)return NaN;return yAP(v);},T.zip234Ann,1.8);
  }

  ctx.restore();// end clip

  // Event labels
  ctx.font="9px system-ui";
  const mo=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
  function eventLabel(h,label,color){
    const t=blockToTime(h);if(t<view.tMin||t>view.tMax)return;
    ctx.fillStyle=color;ctx.save();ctx.translate(xP(t)-2,MG.top+PH-4);ctx.rotate(-Math.PI/2);
    ctx.textAlign="left";ctx.fillText(label+" â€” "+mo[new Date(t).getUTCMonth()]+" "+new Date(t).getUTCFullYear(),0,0);ctx.restore();
  }

  eventLabel(BLOSSOM_ACTIVATION_HEIGHT,"Blossom",T.eventObs);
  {const halvMax=defaultCutoffH===Infinity?Math.ceil(timeToHeight(view.tMax))+200_000:defaultCutoffH;
    for(const hh of halvingHeights(halvMax)){
      const idx=Math.round((hh-1_046_400)/1_680_000)+1;eventLabel(hh,"Halving "+idx,T.eventHalv);}}

  // "Sim written" label
  {const t=writtenTime;if(t>=view.tMin&&t<=view.tMax){ctx.fillStyle=T.written;ctx.save();ctx.translate(xP(t)-2,MG.top+PH-4);ctx.rotate(-Math.PI/2);ctx.textAlign="left";ctx.fillText("Sim written",0,0);ctx.restore();}}

  // Burn event labels
  for(const b of BURN_EVENTS){const t=blockToTime(b.h);if(t>=view.tMin&&t<=view.tMax){ctx.fillStyle=cv("--burnEvent");ctx.save();ctx.translate(xP(t)-2,MG.top+PH-4);ctx.rotate(-Math.PI/2);ctx.textAlign="left";ctx.font="9px system-ui";ctx.fillText(b.label,0,0);ctx.restore();}}

  // ZIP 234 activation label
  if(show.zip234){const t=blockToTime(zip234ActivationHeight);if(t>=view.tMin&&t<=view.tMax){
    ctx.fillStyle=T.zip234Act;ctx.save();ctx.translate(xP(t)-2,MG.top+PH-4);ctx.rotate(-Math.PI/2);
    ctx.textAlign="left";ctx.font="9px system-ui";ctx.fillText("ZIP 234 activation",0,0);ctx.restore();}}

  // Left axis 1 (Issuance/Day)
  if(show.issDay&&axL.issDay){const ax=axL.issDay,bx=MG.left-ax.tickX;
    ctx.fillStyle=T.issObs;ctx.font="11px system-ui";ctx.textAlign="right";
    for(let v=0;v<=yIssDayMax;v+=2_000){const lb=isNarrow?(v>=1000?(v/1000)+"k":String(v)):v.toLocaleString();ctx.fillText(lb,bx,yIP(v)+4);}
    if(!isNarrow&&ax.titleX!=null){ctx.save();ctx.translate(MG.left-ax.titleX,MG.top+PH/2);ctx.rotate(-Math.PI/2);
      ctx.fillStyle=T.issObs;ctx.font="12px system-ui";ctx.textAlign="center";ctx.fillText("Issuance per Day (â“©)",0,0);ctx.restore();}}

  // Left axis 2 (Annual %)
  if(show.annPct&&axL.annPct){const ax=axL.annPct,bx=MG.left-ax.tickX;
    ctx.fillStyle=T.annualObs;ctx.font="10px system-ui";ctx.textAlign="right";
    for(let p=0;p<=yAnnMax;p+=5)ctx.fillText(p+"%",bx,yAP(p)+3);
    if(!isNarrow&&ax.titleX!=null){ctx.save();ctx.translate(MG.left-ax.titleX,MG.top+PH/2);ctx.rotate(-Math.PI/2);
      ctx.fillStyle=T.annualObs;ctx.font="11px system-ui";ctx.textAlign="center";ctx.fillText("Annualized Issuance %",0,0);ctx.restore();}}

  // Right axis (Supply)
  if(show.supply&&axR.supply){const ax=axR.supply,bx=MG.left+PW+ax.tickX;
    ctx.fillStyle=T.supplyObs;ctx.font="11px system-ui";ctx.textAlign="left";
    for(let s=0;s<=ySupMax;s+=3_000_000)ctx.fillText((s/1e6).toFixed(0)+" M",bx,ySP(s)+4);
    if(!isNarrow&&ax.titleX!=null){ctx.save();ctx.translate(MG.left+PW+ax.titleX,MG.top+PH/2);ctx.rotate(Math.PI/2);
      ctx.fillStyle=T.supplyObs;ctx.font="12px system-ui";ctx.textAlign="center";ctx.fillText("Cumulative Supply (â“©)",0,0);ctx.restore();}}

  // X axis
  ctx.fillStyle=T.muted;ctx.font="10px system-ui";ctx.textAlign="center";
  const maxViewH=Math.ceil(timeToHeight(view.tMax))+200_000;
  const allHalvings=halvingHeights(maxViewH);
  for(const hh of allHalvings){
    const t=blockToTime(hh);
    if(t<view.tMin||t>view.tMax)continue;
    const d=new Date(t);
    const label=mo[d.getUTCMonth()]+" "+d.getUTCFullYear();
    ctx.fillText(label,xP(t),MG.top+PH+20);
    ctx.strokeStyle=T.gridLine;ctx.lineWidth=1;
    ctx.beginPath();ctx.moveTo(xP(t),MG.top+PH);ctx.lineTo(xP(t),MG.top+PH+4);ctx.stroke();
  }
  ctx.font="12px system-ui";ctx.fillText("Date (UTC)",MG.left+PW/2,MG.top+PH+42);

  // Frame
  ctx.strokeStyle=T.frameBorder;ctx.lineWidth=1;ctx.strokeRect(MG.left,MG.top,PW,PH);

  // Position activation handle
  updateActHandle();
}

/* ================================================================
   Shared helper: clamp activation height
   ================================================================ */
function clampActivationHeight(h){
  if(h<0)h=0;
  if(h<WRITTEN_HEIGHT)h=WRITTEN_HEIGHT;
  return h;
}

/* ================================================================
   Activation handle positioning
   ================================================================ */
const actHandle=document.getElementById("actHandle");
const actBlockInput=document.getElementById("actBlockInput");
const actDateInput=document.getElementById("actDateInput");

function updateActHandle(){
  if(!show.zip234){actHandle.style.display="none";return;}
  const {CSS_W,CSS_H,MG,PW,PH}=layout;
  if(!PW){actHandle.style.display="none";return;}
  const t=blockToTime(zip234ActivationHeight);
  if(t<view.tMin||t>view.tMax){actHandle.style.display="none";return;}
  const frac=(t-view.tMin)/(view.tMax-view.tMin);
  const xPx=MG.left+frac*PW;

  actHandle.style.display="block";
  actHandle.style.left=xPx+"px";
  const pillEl=actHandle.querySelector('.act-pill');
  const pillHeight=pillEl?pillEl.offsetHeight:40;
  const handleTop=-20; // CSS top value
  const stemHeight=Math.max(10, MG.top - (pillHeight + handleTop) + pillHeight);
  actHandle.querySelector('.act-stem').style.height=stemHeight+"px";

  actBlockInput.value=zip234ActivationHeight.toLocaleString();
  actDateInput.value=fmtDate(blockToTime(zip234ActivationHeight));
}

/* ================================================================
   Extracted handler: activation drag (shared by mouse & touch)
   ================================================================ */
function handleActDrag(clientX){
  const canvasEl=document.getElementById("chart");
  const rect=canvasEl.getBoundingClientRect();
  const {MG,PW}=layout;
  const cssW=parseInt(canvasEl.style.width);
  const mx=(clientX-rect.left)*(cssW/rect.width);
  const frac=Math.max(0,Math.min(1,(mx-MG.left)/PW));
  const t=view.tMin+frac*(view.tMax-view.tMin);
  let h=clampActivationHeight(Math.round(timeToHeight(t)));
  if(h!==zip234ActivationHeight){
    zip234ActivationHeight=h;
    zip234CachedActH=-1;
    requestDraw();
  }
}

/* ================================================================
   Extracted handler: activation block input
   ================================================================ */
function handleActBlockInput(){
  const raw=actBlockInput.value.replace(/,/g,"").trim();
  const v=parseInt(raw);
  if(!isNaN(v)&&v>=0&&v<=100_000_000){
    zip234ActivationHeight=clampActivationHeight(v);
    zip234CachedActH=-1;
    zoomToActivation(zip234ActivationHeight);
  }
  actBlockInput.blur();
}

/* ================================================================
   Extracted handler: activation date input
   ================================================================ */
function handleActDateInput(){
  const raw=actDateInput.value.trim();
  const parsed=Date.parse(raw);
  if(!isNaN(parsed)){
    let h=clampActivationHeight(Math.round(timeToHeight(parsed)));
    if(h>100_000_000)h=100_000_000;
    zip234ActivationHeight=h;
    zip234CachedActH=-1;
    zoomToActivation(zip234ActivationHeight);
  }
  actDateInput.blur();
}

/* ================================================================
   Extracted handler: chart drag
   ================================================================ */
let dragging=false,dragStartX=0,dragStartTMin=0,dragStartTMax=0;

function handleChartDragStart(clientX){
  dragging=true;dragStartX=clientX;dragStartTMin=view.tMin;dragStartTMax=view.tMax;
  document.getElementById("chart").style.cursor="grabbing";
}

function handleChartDragMove(clientX){
  const rect=document.getElementById("chart").getBoundingClientRect();
  const dx=clientX-dragStartX;
  const pxPerMs=(dragStartTMax-dragStartTMin)/rect.width;
  view.tMin=dragStartTMin-dx*pxPerMs;view.tMax=dragStartTMax-dx*pxPerMs;
  clampView();requestDraw();requestComputeForView();
}

/* ================================================================
   Extracted handler: chart wheel (zoom/pan)
   ================================================================ */
function handleChartWheel(e){
  e.preventDefault();
  const rect=document.getElementById("chart").getBoundingClientRect();
  const frac=(e.clientX-rect.left)/rect.width;
  if(e.ctrlKey||e.metaKey||Math.abs(e.deltaY)>50&&Math.abs(e.deltaX)<5){
    const zf=Math.pow(1.002,e.deltaY),span=view.tMax-view.tMin,pivot=view.tMin+frac*span;
    view.tMin=pivot-(pivot-view.tMin)*zf;view.tMax=pivot+(view.tMax-pivot)*zf;
  }else{const shift=(e.deltaX||e.deltaY)*(view.tMax-view.tMin)*0.001;view.tMin+=shift;view.tMax+=shift;}
  clampView();requestDraw();requestComputeForView();
}

/* ================================================================
   Extracted handler: legend toggle
   ================================================================ */
function handleLegendToggle(el){
  const key=el.dataset.series;
  if(key==='default'||key==='zip234'){
    if(show[key]){
      const other=key==='default'?'zip234':'default';
      if(!show[other])return;
    }
    show[key]=!show[key];
  }else{
    show[key]=!show[key];
  }
  el.classList.toggle('active',show[key]);requestDraw();
  if(key==='zip234'||key==='default')requestComputeForView();
}

/* ================================================================
   Extracted handler: chart hover (tooltip)
   ================================================================ */
function handleChartHover(e){
  const tooltip=document.getElementById("tooltip");
  const writtenTipEl=document.getElementById("writtenTip");
  if(dragging||actDragging||data.length<2){tooltip.style.display="none";writtenTipEl.style.display="none";return;}
  const canvasEl=document.getElementById("chart");
  const rect=canvasEl.getBoundingClientRect();
  const cssW=parseInt(canvasEl.style.width),cssH=parseInt(canvasEl.style.height);
  const{MG,PW,PH}=layout;if(!PW){tooltip.style.display="none";return;}
  const mx=(e.clientX-rect.left)*(cssW/rect.width),my=(e.clientY-rect.top)*(cssH/rect.height);

  // Written tooltip + Burn event tooltips
  let specialTipShown=false;
  const wt=writtenTime;
  if(wt>=view.tMin&&wt<=view.tMax){
    const wx=MG.left+((wt-view.tMin)/(view.tMax-view.tMin))*PW;
    if(Math.abs(mx-wx)<12&&my>=MG.top&&my<=MG.top+PH){
      writtenTipEl.innerHTML='This is when this simulation was written.<br>Data before this line is <b>observed</b>; after is <b>expected</b>.';
      writtenTipEl.style.display="block";
      const tipScreenX=rect.left+(wx/cssW)*rect.width;
      const tipScreenY=rect.top+((MG.top+PH+6)/cssH)*rect.height;
      writtenTipEl.style.left=tipScreenX+"px";
      writtenTipEl.style.top=tipScreenY+"px";
      specialTipShown=true;
    }
  }
  if(!specialTipShown){
    for(const b of BURN_EVENTS){
      const bt=blockToTime(b.h);
      if(bt>=view.tMin&&bt<=view.tMax){
        const bx=MG.left+((bt-view.tMin)/(view.tMax-view.tMin))*PW;
        if(Math.abs(mx-bx)<12&&my>=MG.top&&my<=MG.top+PH){
          writtenTipEl.innerHTML=`<b style="color:var(--burnEvent)">${b.label}</b><br>Block ${b.h.toLocaleString()}<br>${fmtDate(bt)} (UTC)<br>${b.zec.toLocaleString()} â“© burned`;
          writtenTipEl.style.display="block";
          const tipScreenX=rect.left+(bx/cssW)*rect.width;
          const tipScreenY=rect.top+((MG.top+PH+6)/cssH)*rect.height;
          writtenTipEl.style.left=tipScreenX+"px";
          writtenTipEl.style.top=tipScreenY+"px";
          specialTipShown=true;
          break;
        }
      }
    }
  }
  if(!specialTipShown)writtenTipEl.style.display="none";

  if(mx<MG.left||mx>MG.left+PW||my<MG.top||my>MG.top+PH){tooltip.style.display="none";return;}
  const mouseTime=view.tMin+((mx-MG.left)/PW)*(view.tMax-view.tMin);

  let lo=0,hi=data.length-1;
  while(lo<hi){const mid=(lo+hi)>>1;data[mid].time<mouseTime?lo=mid+1:hi=mid;}
  if(lo>0&&Math.abs(data[lo-1].time-mouseTime)<Math.abs(data[lo].time-mouseTime))lo--;
  const d=data[lo];

  const isExp=d.h>WRITTEN_HEIGHT,status=isExp?"Expected":"Observed",sc=isExp?"tt-exp":"tt-obs";
  const pct=(d.supply/21e6*100);
  const annStatus=d.annualPctIsExpected?"expected":"observed";
  const annVal=isFinite(d.annualPct)?d.annualPct.toFixed(2)+"%":"â€”";
  const annColor=d.annualPctIsExpected?"var(--annualExp)":"var(--annualObs)";

  let html=`<div><b>Block ${d.h.toLocaleString()}</b> Â· <span class="${sc}">${status}</span></div>`+
    `<div class="tt-muted">${fmtDate(d.time)} (UTC)</div>`;

  const defaultCutoffH2=show.default?Infinity:(show.zip234?zip234ActivationHeight:-1);
  const showDefHere=d.h<=defaultCutoffH2;

  if(showDefHere){
    if(show.supply)html+=`<div style="margin-top:6px"><span style="color:var(--supplyObs)">Supply:</span> ${d.supply.toLocaleString(undefined,{maximumFractionDigits:2})} â“© <span class="tt-muted">(${pct.toFixed(2)}% of cap)</span></div>`;
    if(show.issDay)html+=`<div><span style="color:var(--issObs)">Issuance:</span> ${d.issDay.toLocaleString(undefined,{maximumFractionDigits:1})} â“©/day</div><div class="tt-muted">Per block: ${d.issBlock.toFixed(8)} â“©</div>`;
    if(show.annPct)html+=`<div><span style="color:${annColor}">Annual:</span> ${annVal} <span class="tt-muted">(${annStatus})</span></div>`;
  }

  if(show.zip234&&d.h>=zip234ActivationHeight){
    const z=getZip234At(d.h);
    if(z){
      html+=`<div style="margin-top:6px;border-top:1px solid rgba(148,163,184,0.2);padding-top:4px"><b style="color:var(--zip234Supply)">ZIP 234 (smooth):</b></div>`;
      if(show.supply){const zp=(z.supply/21e6*100);html+=`<div><span style="color:var(--zip234Supply)">Supply:</span> ${z.supply.toLocaleString(undefined,{maximumFractionDigits:2})} â“© <span class="tt-muted">(${zp.toFixed(2)}%)</span></div>`;}
      if(show.issDay)html+=`<div><span style="color:var(--zip234Iss)">Issuance:</span> ${z.issDay.toLocaleString(undefined,{maximumFractionDigits:1})} â“©/day</div><div class="tt-muted">Per block: ${z.issBlock.toFixed(8)} â“©</div>`;
      if(show.annPct){const av=isFinite(z.annualPct)?z.annualPct.toFixed(2)+"%":"â€”";html+=`<div><span style="color:var(--zip234Ann)">Annual:</span> ${av}</div>`;}
    }
  }else if(show.zip234&&d.h<zip234ActivationHeight){
    html+=`<div style="margin-top:4px" class="tt-muted"><i>ZIP 234 activates at block ${zip234ActivationHeight.toLocaleString()}</i></div>`;
  }

  tooltip.innerHTML=html;tooltip.style.display="block";
  const tipW=Math.min(400,window.innerWidth-20);
  tooltip.style.left=Math.min(e.clientX+14,window.innerWidth-tipW-10)+"px";
  tooltip.style.top=Math.max(10,e.clientY-130)+"px";
}

/* ================================================================
   Wire up event listeners (thin wrappers calling named functions)
   ================================================================ */
const canvas=document.getElementById("chart");
const tooltip=document.getElementById("tooltip");
const writtenTip=document.getElementById("writtenTip");
let actDragging=false;

// --- Activation handle: mouse drag ---
actHandle.addEventListener("mousedown",e=>{
  if(e.target.tagName==="INPUT")return;
  actDragging=true;e.preventDefault();e.stopPropagation();
});
window.addEventListener("mousemove",e=>{
  if(!actDragging)return;
  handleActDrag(e.clientX);
});
window.addEventListener("mouseup",()=>{actDragging=false;});

// --- Activation handle: touch drag ---
actHandle.addEventListener("touchstart",e=>{
  if(e.target.tagName==="INPUT")return;
  actDragging=true;e.stopPropagation();
},{passive:true});
window.addEventListener("touchmove",e=>{
  if(!actDragging)return;
  handleActDrag(e.touches[0].clientX);
},{passive:true});
window.addEventListener("touchend",()=>{actDragging=false;});

// --- Activation handle: block input ---
actBlockInput.addEventListener("keydown",e=>{
  if(e.key==="Enter"){handleActBlockInput();}
  e.stopPropagation();
});
actBlockInput.addEventListener("mousedown",e=>e.stopPropagation());
actBlockInput.addEventListener("click",e=>e.stopPropagation());

// --- Activation handle: date input ---
actDateInput.addEventListener("keydown",e=>{
  if(e.key==="Enter"){handleActDateInput();}
  e.stopPropagation();
});
actDateInput.addEventListener("mousedown",e=>e.stopPropagation());
actDateInput.addEventListener("click",e=>e.stopPropagation());

// --- Chart: mouse drag ---
canvas.addEventListener("mousedown",e=>{if(actDragging)return;handleChartDragStart(e.clientX);});
window.addEventListener("mousemove",e=>{if(!dragging||actDragging)return;handleChartDragMove(e.clientX);});
window.addEventListener("mouseup",()=>{dragging=false;canvas.style.cursor="crosshair";});

// --- Chart: wheel ---
canvas.addEventListener("wheel",handleChartWheel,{passive:false});

// --- Chart: double-click ---
canvas.addEventListener("dblclick",()=>resetView());

// --- Chart: touch pan/zoom ---
let lastTouchDist=0;
canvas.addEventListener("touchstart",e=>{if(e.touches.length===1){handleChartDragStart(e.touches[0].clientX);}
  else if(e.touches.length===2){dragging=false;lastTouchDist=Math.abs(e.touches[0].clientX-e.touches[1].clientX);}},{passive:true});
canvas.addEventListener("touchmove",e=>{if(e.touches.length===1&&dragging&&!actDragging){handleChartDragMove(e.touches[0].clientX);}
  else if(e.touches.length===2){const dist=Math.abs(e.touches[0].clientX-e.touches[1].clientX),mid=(e.touches[0].clientX+e.touches[1].clientX)/2;
    if(lastTouchDist>0){const zf=lastTouchDist/dist,rect=canvas.getBoundingClientRect(),frac=(mid-rect.left)/rect.width,
      span=view.tMax-view.tMin,pivot=view.tMin+frac*span;view.tMin=pivot-(pivot-view.tMin)*zf;view.tMax=pivot+(view.tMax-pivot)*zf;
      clampView();requestDraw();requestComputeForView();}lastTouchDist=dist;}},{passive:true});
canvas.addEventListener("touchend",()=>{dragging=false;lastTouchDist=0;});

// --- Chart: hover (tooltip) ---
canvas.addEventListener("mousemove",handleChartHover);
canvas.addEventListener("mouseleave",()=>{tooltip.style.display="none";writtenTip.style.display="none";});

/* ================================================================
   Buttons
   ================================================================ */
document.getElementById("btnReset").addEventListener("click",()=>resetView());
document.getElementById("btnTheme").addEventListener("click",()=>toggleTheme());

// --- Legend toggles ---
document.querySelectorAll('.ltoggle').forEach(el=>{
  el.addEventListener('click',()=>handleLegendToggle(el));
});

canvas.style.cursor="crosshair";

/* ================================================================
   Boot
   ================================================================ */
initTheme();
zip234ActivationHeight=3_687_123;
ensureZip234Cache();
view.tMin=genTime;
view.tMax=blockToTime(6_000_000);
clampView();

targetHeightWanted=Math.max(0,Math.ceil(timeToHeight(view.tMax+ONE_YEAR_MS))+10_000);
document.querySelectorAll('.ltoggle').forEach(el=>{
  const key=el.dataset.series;
  if(key&&show[key]!==undefined)el.classList.toggle('active',show[key]);
});

requestDraw();requestComputeForView();
/* ================
   REGRESSION TESTS
   ================ */
(function runRegressionTests() {
  const results = [];
  function test(name, fn) {
    try {
      const pass = fn();
      results.push({ name, pass });
    } catch (e) {
      results.push({ name, pass: false, error: e.message });
    }
  }

  // --- HTML / DOM structure ---

  test("actHandle element exists", () => {
    return !!document.getElementById("actHandle");
  });

  test("actBlockInput element exists", () => {
    return !!document.getElementById("actBlockInput");
  });

  test("actDateInput element exists", () => {
    return !!document.getElementById("actDateInput");
  });

  test("actHandle has act-pill child", () => {
    const h = document.getElementById("actHandle");
    return h && !!h.querySelector(".act-pill");
  });

  test("actHandle has act-stem child", () => {
    const h = document.getElementById("actHandle");
    return h && !!h.querySelector(".act-stem");
  });

  test("btnReset exists", () => {
    return !!document.getElementById("btnReset");
  });

  test("btnTheme exists", () => {
    return !!document.getElementById("btnTheme");
  });

  test("writtenTip element exists", () => {
    return !!document.getElementById("writtenTip");
  });

  test("legend has 'default' toggle", () => {
    return !!document.querySelector('[data-series="default"]');
  });

  test("legend has 'zip234' toggle", () => {
    return !!document.querySelector('[data-series="zip234"]');
  });

  test("legend has 'supply' toggle", () => {
    return !!document.querySelector('[data-series="supply"]');
  });

  test("legend has 'issDay' toggle", () => {
    return !!document.querySelector('[data-series="issDay"]');
  });

  test("legend has 'annPct' toggle", () => {
    return !!document.querySelector('[data-series="annPct"]');
  });

  // --- Constants and initial state ---

  test("WRITTEN_HEIGHT is defined and > 3,000,000", () => {
    return typeof WRITTEN_HEIGHT === "number" && WRITTEN_HEIGHT > 3_000_000;
  });

  test("BLOSSOM_ACTIVATION_HEIGHT is 653600", () => {
    return BLOSSOM_ACTIVATION_HEIGHT === 653600;
  });

  test("zip234ActivationHeight is >= WRITTEN_HEIGHT at boot", () => {
    return zip234ActivationHeight >= WRITTEN_HEIGHT;
  });

  test("zip234ActivationHeight default is 3,687,123", () => {
    return zip234ActivationHeight === 3_687_123;
  });

  test("MAX_MONEY_ZEC is 21,000,000", () => {
    return MAX_MONEY_ZEC === 21_000_000;
  });

  test("ZIP234_K is defined and positive and < 1", () => {
    return typeof ZIP234_K === "number" && ZIP234_K > 0 && ZIP234_K < 1;
  });

  // --- Toggle state ---

  test("show.default is true at boot", () => {
    return show.default === true;
  });

  test("show.zip234 is true at boot", () => {
    return show.zip234 === true;
  });

  test("show.supply is true at boot", () => {
    return show.supply === true;
  });

  test("show.issDay is true at boot", () => {
    return show.issDay === true;
  });

  test("show.annPct is false at boot", () => {
    return show.annPct === false;
  });

  // --- Toggle constraint: can't turn off both default and zip234 ---

  test("default/zip234 mutual exclusion constraint: can't both be off", () => {
    // Save state
    const origD = show.default, origZ = show.zip234;
    // Simulate: both on, turn off default â†’ zip234 must stay on
    show.default = true; show.zip234 = true;
    // Simulate turning off default: only allowed if zip234 is on
    const canTurnOffDefault = show.zip234;
    // Simulate turning off zip234 too: should be blocked
    show.default = false;
    const canTurnOffZip234 = show.default; // default is off, so zip234 can't be turned off
    // Restore
    show.default = origD; show.zip234 = origZ;
    return canTurnOffDefault === true && canTurnOffZip234 === false;
  });

  // --- Issuance logic ---

  test("issuance_per_block(0) is 0 (slow start)", () => {
    return issuance_per_block(0) === 0n;
  });

  test("issuance_per_block(20000) is 1250000000 (full subsidy pre-Blossom)", () => {
    return issuance_per_block(20000) === 1250000000n;
  });

  test("issuance_per_block(653600) is 625000000 (Blossom halves block subsidy)", () => {
    return issuance_per_block(653600) === 625000000n;
  });

  test("issuance_per_block at halving 1 (1046400) is 312500000", () => {
    return issuance_per_block(1046400) === 312500000n;
  });

  test("issuance_per_block at halving 2 (2726400) is 156250000", () => {
    return issuance_per_block(2726400) === 156250000n;
  });

  test("issuance_per_block just before halving 2 is 312500000", () => {
    return issuance_per_block(2726399) === 312500000n;
  });

  // --- Time anchors ---

  test("Genesis time is Oct 28, 2016", () => {
    return TIME_ANCHORS[0].time === Date.UTC(2016, 9, 28, 7, 56);
  });

  test("blockToTime(0) equals genesis time", () => {
    return blockToTime(0) === TIME_ANCHORS[0].time;
  });

  test("blockToTime is monotonically increasing", () => {
    const h = [0, 100000, 653600, 1046400, 2000000, 2726400, 3000000];
    for (let i = 1; i < h.length; i++) {
      if (blockToTime(h[i]) <= blockToTime(h[i - 1])) return false;
    }
    return true;
  });

  // --- Halving heights ---

  test("halvingHeights returns correct first halving", () => {
    const hh = halvingHeights(2000000);
    return hh.length >= 1 && hh[0] === 1046400;
  });

  test("halvingHeights includes halving 2 at 2726400", () => {
    const hh = halvingHeights(3000000);
    return hh.includes(2726400);
  });

  test("halving spacing is 1,680,000", () => {
    const hh = halvingHeights(6000000);
    for (let i = 1; i < hh.length; i++) {
      if (hh[i] - hh[i - 1] !== 1680000) return false;
    }
    return true;
  });

  // --- ZIP 234 math ---

  test("getZip234At returns null for height below activation", () => {
    return getZip234At(zip234ActivationHeight - 1) === null;
  });

  test("getZip234At returns object at activation height", () => {
    const z = getZip234At(zip234ActivationHeight);
    return z !== null && typeof z.supply === "number" && typeof z.issBlock === "number";
  });

  test("ZIP 234 supply is monotonically increasing", () => {
    const actH = zip234ActivationHeight;
    const heights = [actH, actH + 10000, actH + 100000, actH + 500000];
    let prev = 0;
    for (const h of heights) {
      const z = getZip234At(h);
      if (!z || z.supply <= prev) return false;
      prev = z.supply;
    }
    return true;
  });

  test("ZIP 234 issuance per block is positive and decreasing", () => {
    const actH = zip234ActivationHeight;
    const heights = [actH, actH + 100000, actH + 500000, actH + 1000000];
    let prev = Infinity;
    for (const h of heights) {
      const z = getZip234At(h);
      if (!z || z.issBlock <= 0 || z.issBlock >= prev) return false;
      prev = z.issBlock;
    }
    return true;
  });

  test("ZIP 234 supply never exceeds 21M", () => {
    const z = getZip234At(zip234ActivationHeight + 10_000_000);
    return z !== null && z.supply <= 21_000_000;
  });

  // --- sumIssuanceRangeClean ---

  test("sumIssuanceRangeClean(0,0) is 0", () => {
    return sumIssuanceRangeClean(0, 0) === 0n;
  });

  test("sumIssuanceRangeClean(0,1) equals issuance_per_block(0)", () => {
    return sumIssuanceRangeClean(0, 1) === issuance_per_block(0);
  });

  test("sumIssuanceRangeClean agrees with brute force for small range", () => {
    let brute = 0n;
    for (let h = 20000; h < 20010; h++) brute += issuance_per_block(h);
    return sumIssuanceRangeClean(20000, 20010) === brute;
  });

  // --- View state ---

  test("view.tMin is at or near genesis at boot", () => {
    return Math.abs(view.tMin - genTime) < 86400000; // within 1 day
  });

  test("view.tMax corresponds to roughly block 6M", () => {
    const expected = blockToTime(6_000_000);
    return Math.abs(view.tMax - expected) < 86400000 * 30; // within 30 days
  });

  // --- Activation height minimum constraint ---

  test("Activation height clamp: direct set below WRITTEN_HEIGHT is rejected", () => {
    const saved = zip234ActivationHeight;
    // Simulate what the drag handler should do: set to a low value
    const tooLow = WRITTEN_HEIGHT - 100_000;
    zip234ActivationHeight = tooLow;
    // Now call updateActHandle which is what drag/input paths end with.
    // The constraint should be enforced somewhere in the pipeline.
    // If the code has no clamp, zip234ActivationHeight stays at tooLow â€” that's the bug.
    // We need to check: does any code path actually prevent this?

    // Check if the mousemove handler source contains a clamp against WRITTEN_HEIGHT
    const handlers = [
      // Look at all mousemove listeners â€” we can't easily extract them,
      // but we can inspect the source of known functions
      updateActHandle.toString(),
    ];

    // Restore before we forget
    zip234ActivationHeight = saved;

    // The real test: search the entire script for clamping logic
    const scripts = document.querySelectorAll('script');
    let scriptSource = '';
    for (const s of scripts) {
      if (s.textContent.includes('zip234ActivationHeight')) {
        scriptSource = s.textContent;
        break;
      }
    }

    // There must be code that clamps zip234ActivationHeight to >= WRITTEN_HEIGHT
    // in the drag handler, block input handler, AND date input handler
    const hasDragClamp = scriptSource.includes('WRITTEN_HEIGHT') && 
      (scriptSource.match(/actDragging[\s\S]{0,500}WRITTEN_HEIGHT/) !== null ||
       scriptSource.match(/WRITTEN_HEIGHT[\s\S]{0,500}actDragging/) !== null);

    const hasBlockInputClamp = scriptSource.match(
      /actBlockInput[\s\S]{0,800}WRITTEN_HEIGHT|WRITTEN_HEIGHT[\s\S]{0,800}actBlockInput/
    ) !== null;

    const hasDateInputClamp = scriptSource.match(
      /actDateInput[\s\S]{0,800}WRITTEN_HEIGHT|WRITTEN_HEIGHT[\s\S]{0,800}actDateInput/
    ) !== null;

    if (!hasDragClamp) console.warn("  âš  No WRITTEN_HEIGHT clamp found near drag handler");
    if (!hasBlockInputClamp) console.warn("  âš  No WRITTEN_HEIGHT clamp found near block input handler");
    if (!hasDateInputClamp) console.warn("  âš  No WRITTEN_HEIGHT clamp found near date input handler");

    return hasDragClamp && hasBlockInputClamp && hasDateInputClamp;
  });

  test("Activation height clamp: functional test via block input", () => {
    const saved = zip234ActivationHeight;
    const input = document.getElementById("actBlockInput");
    if (!input) return false;

    // Set input to a value below WRITTEN_HEIGHT and fire Enter
    const tooLow = WRITTEN_HEIGHT - 500_000;
    input.value = String(tooLow);
    input.dispatchEvent(new KeyboardEvent('keydown', { key: 'Enter', bubbles: true }));

    // After the handler runs, activation height should still be >= WRITTEN_HEIGHT
    const pass = zip234ActivationHeight >= WRITTEN_HEIGHT;

    if (!pass) {
      console.warn(`  âš  Block input set activation to ${zip234ActivationHeight}, below WRITTEN_HEIGHT (${WRITTEN_HEIGHT})`);
    }

    // Restore
    zip234ActivationHeight = saved;
    zip234CachedActH = -1; // force recalc
    requestDraw();
    return pass;
  });

  test("Activation height clamp: functional test via date input", () => {
    const saved = zip234ActivationHeight;
    const input = document.getElementById("actDateInput");
    if (!input) return false;

    // Use genesis date â€” way before WRITTEN_HEIGHT
    input.value = "Oct 28, 2016";
    input.dispatchEvent(new KeyboardEvent('keydown', { key: 'Enter', bubbles: true }));

    const pass = zip234ActivationHeight >= WRITTEN_HEIGHT;

    if (!pass) {
      console.warn(`  âš  Date input set activation to ${zip234ActivationHeight}, below WRITTEN_HEIGHT (${WRITTEN_HEIGHT})`);
    }

    zip234ActivationHeight = saved;
    zip234CachedActH = -1;
    requestDraw();
    return pass;
  });

  // --- CSS / styling checks ---

  test("actHandle is above chart (negative or zero top)", () => {
    const h = document.getElementById("actHandle");
    if (!h) return false;
    const top = parseInt(getComputedStyle(h).top) || parseInt(h.style.top) || -20;
    return top <= 0;
  });

  // --- Report ---

  const passed = results.filter(r => r.pass).length;
  const failed = results.filter(r => !r.pass).length;
  const total = results.length;

  console.log(`%c=== REGRESSION TESTS: ${passed}/${total} passed, ${failed} failed ===`,
    failed > 0 ? "color:red;font-weight:bold;font-size:14px" : "color:green;font-weight:bold;font-size:14px");

  for (const r of results) {
    if (r.pass) {
      console.log(`  %câœ“ ${r.name}`, "color:green");
    } else {
      console.log(`  %câœ— ${r.name}${r.error ? " â€” " + r.error : ""}`, "color:red;font-weight:bold");
    }
  }

  if (failed > 0) {
    console.warn(`âš ï¸ ${failed} regression test(s) FAILED â€” check for regressions before shipping!`);
  }
})();
</script>
</body>
</html>

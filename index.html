<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Zcash Supply — Brute Force</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #0f172a; color: #e2e8f0; font-family: system-ui, sans-serif;
         display: flex; flex-direction: column; align-items: center; padding: 24px; }
  h1 { font-size: 1.4rem; color: #f59e0b; margin-bottom: 4px; }
  .sub { font-size: 0.85rem; color: #94a3b8; margin-bottom: 16px; }
  .sub a { color: #38bdf8; }
  #progress-box { margin-bottom: 16px; text-align: center; }
  #progress-bar-outer { width: 600px; height: 18px; background: #1e293b;
    border-radius: 9px; overflow: hidden; margin: 8px auto; }
  #progress-bar-inner { width: 0%; height: 100%; background: #f59e0b;
    transition: width 0.1s; }
  #progress-text { font-size: 0.8rem; color: #94a3b8; }
  canvas { border-radius: 8px; background: #0f172a; }
  .legend { display: flex; gap: 24px; margin-top: 12px; font-size: 0.82rem; }
  .legend span { display: flex; align-items: center; gap: 6px; }
  .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; }
  #tooltip { position: fixed; display: none; background: #1e293b; color: #e2e8f0;
    border: 1px solid #334155; border-radius: 6px; padding: 8px 12px;
    font-size: 0.78rem; pointer-events: none; z-index: 10; line-height: 1.5; }
</style>
</head>
<body>

<h1>Zcash Supply &amp; Issuance — Brute Force</h1>
<p class="sub">Calls <a href="https://github.com/zooko/zcash-network-sustainability-simulator/blob/c520a60/issuance_per_block.js"
   target="_blank">issuance_per_block()</a> for every block 0 → 3,000,000</p>

<div id="progress-box">
  <div id="progress-bar-outer"><div id="progress-bar-inner"></div></div>
  <div id="progress-text">Initializing…</div>
</div>

<canvas id="chart" width="900" height="500"></canvas>

<div class="legend">
  <span><span class="dot" style="background:#f59e0b"></span> Cumulative Supply (left axis)</span>
  <span><span class="dot" style="background:#22d3ee"></span> Issuance per Block (right axis)</span>
  <span><span class="dot" style="background:rgba(239,68,68,0.5)"></span> Halvings</span>
</div>

<div id="tooltip"></div>

<script>
// ===== EXACT function from the repo (unmodified) =====
function issuance_per_block(blockheight) {
    const MAX_BLOCK_SUBSIDY = 1250000000n;
    const SLOW_START_INTERVAL = 20000;
    const SLOW_START_SHIFT = 10000;
    const SLOW_START_RATE = 62500n;
    const BLOSSOM_ACTIVATION_HEIGHT = 653600;
    const BLOSSOM_POW_TARGET_SPACING_RATIO = 2n;
    const PRE_BLOSSOM_HALVING_INTERVAL = 840000;
    const POST_BLOSSOM_HALVING_INTERVAL = 1680000n;

    const h = BigInt(blockheight);

    if (blockheight < SLOW_START_SHIFT) {
        return SLOW_START_RATE * h;
    }
    if (blockheight < SLOW_START_INTERVAL) {
        return SLOW_START_RATE * (h + 1n);
    }

    let halvings;
    if (blockheight >= BLOSSOM_ACTIVATION_HEIGHT) {
        const scaledHalvings =
            BigInt(BLOSSOM_ACTIVATION_HEIGHT - SLOW_START_SHIFT) * BLOSSOM_POW_TARGET_SPACING_RATIO
            + (h - BigInt(BLOSSOM_ACTIVATION_HEIGHT));
        halvings = Number(scaledHalvings / POST_BLOSSOM_HALVING_INTERVAL);
    } else {
        halvings = Math.floor((blockheight - SLOW_START_SHIFT) / PRE_BLOSSOM_HALVING_INTERVAL);
    }

    if (halvings >= 64) return 0n;

    if (blockheight >= BLOSSOM_ACTIVATION_HEIGHT) {
        return (MAX_BLOCK_SUBSIDY / BLOSSOM_POW_TARGET_SPACING_RATIO) >> BigInt(halvings);
    } else {
        return MAX_BLOCK_SUBSIDY >> BigInt(halvings);
    }
}

// ===== Brute-force computation =====
const MAX_HEIGHT = 3_000_000;
const SAMPLE_EVERY = 1000;          // store a point every 1000 blocks for chart
const ZATOSHI = 100_000_000;        // 1 ZEC
const PROGRESS_EVERY = 50_000;      // update progress bar

const data = [];                    // { h, supply (ZEC), iss (ZEC) }

async function compute() {
    const bar = document.getElementById('progress-bar-inner');
    const txt = document.getElementById('progress-text');

    let cumulative = 0n;            // running total in zatoshi

    for (let h = 0; h <= MAX_HEIGHT; h++) {
        const iss = issuance_per_block(h);
        cumulative += iss;

        if (h % SAMPLE_EVERY === 0 || h === MAX_HEIGHT) {
            data.push({
                h: h,
                supply: Number(cumulative) / ZATOSHI,
                iss: Number(iss) / ZATOSHI
            });
        }

        if (h % PROGRESS_EVERY === 0) {
            const pct = (h / MAX_HEIGHT * 100).toFixed(1);
            bar.style.width = pct + '%';
            txt.textContent = `Block ${h.toLocaleString()} / ${MAX_HEIGHT.toLocaleString()}  (${pct}%)`;
            await new Promise(r => setTimeout(r, 0));   // yield to UI
        }
    }

    bar.style.width = '100%';
    txt.textContent = `Done — ${(MAX_HEIGHT + 1).toLocaleString()} blocks computed, ${data.length.toLocaleString()} sample points`;
    draw();
}

// ===== Drawing =====
function draw() {
    const canvas = document.getElementById('chart');
    const dpr = window.devicePixelRatio || 1;
    const CSS_W = 900, CSS_H = 500;
    canvas.width = CSS_W * dpr; canvas.height = CSS_H * dpr;
    canvas.style.width = CSS_W + 'px'; canvas.style.height = CSS_H + 'px';
    const ctx = canvas.getContext('2d');
    ctx.scale(dpr, dpr);

    const MG = { top: 32, right: 64, bottom: 52, left: 64 };
    const PW = CSS_W - MG.left - MG.right;
    const PH = CSS_H - MG.top - MG.bottom;

    ctx.fillStyle = '#0f172a'; ctx.fillRect(0, 0, CSS_W, CSS_H);

    const xMax = MAX_HEIGHT;
    const ySupMax = Math.ceil(data[data.length - 1].supply / 1_000_000) * 1_000_000 + 1_000_000;
    const yIssMax = 14;  // ZEC — just above 12.5

    const xP  = h => MG.left + (h / xMax) * PW;
    const ySP = s => MG.top + PH - (s / ySupMax) * PH;
    const yIP = v => MG.top + PH - (v / yIssMax) * PH;

    // grid
    ctx.strokeStyle = 'rgba(148,163,184,0.08)'; ctx.lineWidth = 1;
    for (let s = 0; s <= ySupMax; s += 2_000_000) {
        ctx.beginPath(); ctx.moveTo(MG.left, ySP(s));
        ctx.lineTo(MG.left + PW, ySP(s)); ctx.stroke();
    }

    // 21M cap line
    ctx.setLineDash([6, 4]); ctx.strokeStyle = 'rgba(245,158,11,0.25)';
    ctx.beginPath(); ctx.moveTo(MG.left, ySP(21_000_000));
    ctx.lineTo(MG.left + PW, ySP(21_000_000)); ctx.stroke();
    ctx.setLineDash([]);

    // Blossom vertical
    ctx.setLineDash([4, 4]); ctx.strokeStyle = 'rgba(96,165,250,0.35)'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(xP(653_600), MG.top);
    ctx.lineTo(xP(653_600), MG.top + PH); ctx.stroke();
    ctx.setLineDash([]);

    // halving verticals
    const halvArr = [1_046_400, 2_726_400];
    ctx.setLineDash([4, 4]); ctx.strokeStyle = 'rgba(239,68,68,0.35)'; ctx.lineWidth = 1;
    for (const hv of halvArr) {
        if (hv > xMax) continue;
        ctx.beginPath(); ctx.moveTo(xP(hv), MG.top);
        ctx.lineTo(xP(hv), MG.top + PH); ctx.stroke();
    }
    ctx.setLineDash([]);

    // supply fill
    ctx.beginPath(); ctx.moveTo(xP(data[0].h), ySP(data[0].supply));
    for (const d of data) ctx.lineTo(xP(d.h), ySP(d.supply));
    ctx.lineTo(xP(data[data.length - 1].h), ySP(0));
    ctx.lineTo(xP(data[0].h), ySP(0)); ctx.closePath();
    const grad = ctx.createLinearGradient(0, MG.top, 0, MG.top + PH);
    grad.addColorStop(0, 'rgba(245,158,11,0.18)');
    grad.addColorStop(1, 'rgba(245,158,11,0.01)');
    ctx.fillStyle = grad; ctx.fill();

    // supply line
    ctx.strokeStyle = '#f59e0b'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(xP(data[0].h), ySP(data[0].supply));
    for (const d of data) ctx.lineTo(xP(d.h), ySP(d.supply));
    ctx.stroke();

    // issuance step curve
    ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.moveTo(xP(data[0].h), yIP(data[0].iss));
    for (let i = 1; i < data.length; i++) {
        ctx.lineTo(xP(data[i].h), yIP(data[i - 1].iss));   // horizontal
        ctx.lineTo(xP(data[i].h), yIP(data[i].iss));        // vertical
    }
    ctx.stroke();

    // left axis labels (Supply)
    ctx.fillStyle = '#d97706'; ctx.font = '11px system-ui'; ctx.textAlign = 'right';
    for (let s = 0; s <= ySupMax; s += 2_000_000)
        ctx.fillText((s / 1e6).toFixed(0) + ' M', MG.left - 6, ySP(s) + 4);
    ctx.save(); ctx.translate(14, MG.top + PH / 2); ctx.rotate(-Math.PI / 2);
    ctx.fillStyle = '#d97706'; ctx.font = '12px system-ui'; ctx.textAlign = 'center';
    ctx.fillText('Cumulative Supply (ZEC)', 0, 0); ctx.restore();

    // right axis labels (Issuance)
    ctx.fillStyle = '#22d3ee'; ctx.font = '11px system-ui'; ctx.textAlign = 'left';
    for (let v = 0; v <= yIssMax; v += 2)
        ctx.fillText(v.toFixed(1), MG.left + PW + 6, yIP(v) + 4);
    ctx.save(); ctx.translate(CSS_W - 8, MG.top + PH / 2); ctx.rotate(Math.PI / 2);
    ctx.fillStyle = '#0891b2'; ctx.font = '12px system-ui'; ctx.textAlign = 'center';
    ctx.fillText('Issuance per Block (ZEC)', 0, 0); ctx.restore();

    // x axis
    ctx.fillStyle = '#94a3b8'; ctx.font = '11px system-ui'; ctx.textAlign = 'center';
    for (let bh = 0; bh <= xMax; bh += 500_000)
        ctx.fillText((bh / 1e6).toFixed(1) + ' M', xP(bh), MG.top + PH + 20);
    ctx.font = '12px system-ui';
    ctx.fillText('Block Height', MG.left + PW / 2, MG.top + PH + 42);

    // event labels
    ctx.font = '9px system-ui';
    ctx.fillStyle = 'rgba(96,165,250,0.55)';
    ctx.save(); ctx.translate(xP(653_600) - 2, MG.top + PH - 4);
    ctx.rotate(-Math.PI / 2); ctx.textAlign = 'left';
    ctx.fillText('Blossom', 0, 0); ctx.restore();
    ctx.fillStyle = 'rgba(239,68,68,0.5)';
    for (let i = 0; i < halvArr.length; i++) {
        if (halvArr[i] > xMax) continue;
        ctx.save(); ctx.translate(xP(halvArr[i]) - 2, MG.top + PH - 4);
        ctx.rotate(-Math.PI / 2); ctx.textAlign = 'left';
        ctx.fillText('Halving ' + (i + 1), 0, 0); ctx.restore();
    }

    ctx.strokeStyle = '#1e293b'; ctx.lineWidth = 1;
    ctx.strokeRect(MG.left, MG.top, PW, PH);

    // tooltip
    const tooltip = document.getElementById('tooltip');
    canvas.addEventListener('mousemove', function (e) {
        const rect = canvas.getBoundingClientRect();
        const mx = (e.clientX - rect.left) * (CSS_W / rect.width);
        const my = (e.clientY - rect.top) * (CSS_H / rect.height);
        if (mx < MG.left || mx > MG.left + PW || my < MG.top || my > MG.top + PH) {
            tooltip.style.display = 'none'; return;
        }
        const blockH = Math.max(0, Math.min(MAX_HEIGHT, Math.round(((mx - MG.left) / PW) * xMax)));

        // find nearest sample
        let idx = Math.round(blockH / SAMPLE_EVERY);
        idx = Math.max(0, Math.min(data.length - 1, idx));
        const d = data[idx];

        tooltip.innerHTML =
            '<b>Block ' + d.h.toLocaleString() + '</b><br>' +
            '<span style="color:#f59e0b">Supply:</span> ' +
            d.supply.toLocaleString(undefined, { maximumFractionDigits: 2 }) +
            ' ZEC (' + (d.supply / 21_000_000 * 100).toFixed(2) + '%)<br>' +
            '<span style="color:#22d3ee">Issuance:</span> ' +
            d.iss.toFixed(8) + ' ZEC/block';
        tooltip.style.display = 'block';
        tooltip.style.left = Math.min(e.clientX + 16, window.innerWidth - 260) + 'px';
        tooltip.style.top = (e.clientY - 76) + 'px';
    });
    canvas.addEventListener('mouseleave', () => { tooltip.style.display = 'none'; });
}

compute();
</script>
</body>
</html>
